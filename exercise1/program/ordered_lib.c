#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <omp.h>
#include <mpi.h>
#include "ordered_header.h"

#include<unistd.h>

// void savePGM(const char* filename, unsigned char* image, int xwidth, int rows_per_proc, int maxval)
// {
//     FILE* file = fopen(filename, "w");
//     if (file)
//     {
//         fprintf(file, "P5\n# generated by\n# Lisa Da Vinchie\n%d %d %d\n", xwidth, rows_per_proc, maxval);

//         for (int i=0; i < xwidth * rows_per_proc; i++){
//             fprintf(file, "%c", image[i] * 255);
//         }
//         // fwrite(image, sizeof(unsigned char), xwidth * rows_per_proc, file);
//         fclose(file);
//     }
// }

void savePGM(const char* filename, unsigned char* image, int xwidth, int ywidth, int rows_per_proc, int startrow, int maxval, int rank)
{

    // for(int idx = 0; idx < (xwidth * rows_per_proc); idx++)
    // {
    //   image[idx] = image[idx] * 255;
    //   // printf("%d ", (int)image[idx]);
    //   // if((idx + 1) % 15 == 0)
    //   //   printf("\n");
    // }
    MPI_Barrier(MPI_COMM_WORLD);
    MPI_File file;
    MPI_File_open(MPI_COMM_WORLD, filename, MPI_MODE_CREATE | MPI_MODE_WRONLY, MPI_INFO_NULL, &file);

    // Calculate the local offset within the file
    MPI_Offset local_offset = startrow * xwidth * sizeof(unsigned char);

    // Set the file view for each process
    MPI_File_set_view(file, local_offset, MPI_UNSIGNED_CHAR, MPI_UNSIGNED_CHAR, "native", MPI_INFO_NULL);
    // Write the PGM header
    if (rank == 0) {
        char header[50]; // Adjust the size as needed
        sprintf(header, "P5\n# generated by\n# Lisa Da Vinchie\n%d %d %d\n", xwidth, ywidth, maxval);
        MPI_File_write(file, header, strlen(header), MPI_CHAR, MPI_STATUS_IGNORE);
    }

    MPI_Barrier(MPI_COMM_WORLD);

    // Write the local data to the file
    MPI_File_write(file, image, xwidth * rows_per_proc, MPI_UNSIGNED_CHAR, MPI_STATUS_IGNORE);

    // Close the file
    MPI_File_close(&file);
}

void write_pgm_image(unsigned char *image, int xsize, int ysize, int maxval, char* filename)
{

        FILE* image_file; 
        image_file = fopen(filename, "wb");
        if(image_file == NULL)
        {
          printf("There was an error while opening the image file\n");
        }
        fprintf(image_file, "P5\n# generated by\n# Lisa Da Vinchie\n%d %d %d\n", xsize, ysize, maxval);
    
    
        for (int i=0; i < xsize * ysize; i++){
            fprintf(image_file, "%c", image[i] * 255);
        }

        fclose(image_file);
}

void save_snapshot(unsigned char* image, int xwidth, int ywidth, int maxval, char* snap_title, int first_index, int image_idx)
{
  char title[50];
  snprintf(title, 50, "%s_%d_%05d.pgm", snap_title, first_index, image_idx);
  write_pgm_image(image, xwidth, ywidth, maxval, title);
}

void print_matrix(unsigned char* image, int xwidth, int ywidth)
{
  int idx = 0;
  for(int x = 0; x < xwidth; x++)
  {
    for(int y = 0; y < ywidth; y++)
    {
      printf("%d ", (int)image[idx]);
      idx++;
    }
    printf("\n");
  }
}

void read_header(int *xsize, int *ysize, int *maxval, char *filename){

    FILE *file = fopen(filename, "rb");
    if(!file){
        perror("Error opening file\n");
    }

    char MagicN[2];

    if(fread(MagicN, 1, 2, file) != 2 || MagicN[0] != 'P' || MagicN[1] != '5'){
        printf("Not a PGM P5 image\n");
        fclose(file);
    }

    // int xsize = -1, ysize = -1, color_maxval = -1;
    char line[50];
    while(fgets(line, sizeof(line), file)){
        if(line[0] == '#'){
            continue;
        }
        else if(sscanf(line, "%d %d\n%d", xsize, ysize, maxval) == 3){
            break;
        } 
    }


    if(*maxval > 255){
        printf("Maxval is too big\n");
        fclose(file);
    }

    else{
        sscanf(line, "%d %d %d\n", xsize, ysize, maxval);
    }
    fclose(file);
}


void read_pgm_image(unsigned char* image, int xsize, int ysize, int maxval, char* filename)
{
    int elements = 0;

    FILE *file = fopen(filename, "rb");
    if(!file){
        perror("Error opening file\n");
    }

    char MagicN[2];

    if(fread(MagicN, 1, 2, file) != 2 || MagicN[0] != 'P' || MagicN[1] != '5'){
        printf("Not a PGM P5 image\n");
        fclose(file);
    }


    char line[50];
    while(fgets(line, sizeof(line), file)){
        if(line[0] == '#'){
            continue;
        }
        else if(sscanf(line, "%d %d\n%d", &xsize, &ysize, &maxval) == 3){
            break;
        } 
    }


    if(maxval > 255){
        printf("Maxval is too big\n");
        fclose(file);
    }

    else{
        sscanf(line, "%d %d %d\n", &xsize, &ysize, &maxval);
    }
    elements = fread(image, sizeof(unsigned char), xsize * ysize, file);

    for(int idx = 0; idx < xsize * ysize; idx++){
        image[idx] = image[idx]/255;
    }

    fclose(file);
}

void gather_images(unsigned char* partial_image, unsigned char* full_image, int xwidth, int ywidth, int n_procs, int rank)
{

  // Calculate displacement and counts, that will be necessary for gathering the images
  if(rank == 0){
      int displacement[n_procs]; // Start index of every pack of data in the full matrix
      int counts[n_procs]; // Number of cells to gather from each process
      int check = -1; // Variable used to check wether MPI_Gatherv was executed successfully or not

        for(int r = 0; r < n_procs; r++)
        {
          int rows_per_proc = ywidth / n_procs; // rows per process
          int remaining_rows = ywidth % n_procs;

          if(r < remaining_rows)
            rows_per_proc++;
          
          counts[r] = rows_per_proc * xwidth;

          displacement[r] = r * rows_per_proc;

          if(r >= remaining_rows)
            displacement[r] += remaining_rows; 
          
          displacement[r] = displacement[r] * xwidth;

        }


        check = MPI_Gatherv(partial_image, counts[0], MPI_UNSIGNED_CHAR, full_image, counts, displacement, MPI_UNSIGNED_CHAR, 0, MPI_COMM_WORLD);
        
        if(check != MPI_SUCCESS)
        {
          printf("Error while gathering in rank %d\n", rank);
          MPI_Abort(MPI_COMM_WORLD, 1);
        } 
    }

    else{
      int check = -1; // Variable used to check wether MPI_Gatherv was executed successfully or not

      int rows_per_proc = ywidth / n_procs; // rows per process
      int remaining_rows = ywidth % n_procs;

      if(rank < remaining_rows)
        rows_per_proc++;
      
      int cells_per_proc = rows_per_proc * xwidth; // Number of cells generated by this process

      check = MPI_Gatherv(partial_image, cells_per_proc, MPI_UNSIGNED_CHAR, NULL, NULL, NULL, MPI_UNSIGNED_CHAR, 0, MPI_COMM_WORLD);
        
      if(check != MPI_SUCCESS)
        printf("Error while gathering in rank %d\n", rank);
 
    }
}

void initialise_playground(int kx, int ky, int maxval, char* fname, int argc, char **argv)
{

  // initialise_playground(k, maxval, fname, argc, argv);

  int xwidth = kx;
  int ywidth = ky;

  int rank; // ID of the actual process
  int n_procs; // Total number of porcesses
  int thread_id; // ID of the actual thread 
  int n_threads; // Total number of threads
  int mpi_provided_thread_level;

  int check = -1; // variable used to check the status of MPI functions

  printf("Start MPI environment\n");
  check = MPI_Init_thread(&argc, &argv, MPI_THREAD_FUNNELED, &mpi_provided_thread_level);


  if(check != MPI_SUCCESS){
    printf("A problem arised while initialising MPI\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }
  if (mpi_provided_thread_level < MPI_THREAD_FUNNELED )
  {
    printf("A problem arised when asking for MPI_THREAD_FUNNELED levels\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }
  // else
  // {
  //   if(rank == 0)
  //     printf("Provided Thread level: %d\n", mpi_provided_thread_level);
  // }


  // Get the rank of the process and the total number of processes 
  MPI_Comm_size(MPI_COMM_WORLD, &n_procs);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);


  // Divide rows between the processes
  int row_per_proc = ywidth / n_procs;
  int remaining_rows_per_proc = ywidth % n_procs;

  if(rank < remaining_rows_per_proc)
    row_per_proc++;
  
  int startrow_rank = rank * row_per_proc;

  if(rank >= remaining_rows_per_proc)
    startrow_rank += remaining_rows_per_proc;  

  const int cells_per_proc = row_per_proc * xwidth;
  
  // Allocate memory for a partial image
  unsigned char* image = NULL;
  image = (unsigned char*)malloc(cells_per_proc * sizeof(unsigned char));

  if(image == NULL){
    printf("Memory allocation of \"image\" failed\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }

  // Create a random playground in parallel
  #pragma omp parallel
  {
    // get the total number of threads
    #pragma omp master
    {
      n_threads = omp_get_num_threads();
      printf("\nSockets: %d\nThreads: %d\n", n_procs, n_threads);
    }

    // Get the number of the actual thread
    thread_id = omp_get_thread_num();
    

    srand(time(NULL) + rank);
    
    // Create a random playground
    #pragma omp for schedule(static)
      for (int idx = 0; idx < cells_per_proc; idx++){
        image[idx] = (unsigned char)((int)rand()%2);
      }
  }

  MPI_Barrier(MPI_COMM_WORLD);

  // Allocate memory to gather the results of the images that were generated separately
  // unsigned char* full_image = (unsigned char*)malloc(xwidth * ywidth * sizeof(unsigned char));

  // Gather images into full image
  // gather_images(image, full_image, xwidth, ywidth, n_procs, rank);
  

  // // Save playground
  // if(rank == 0)
  //   write_pgm_image(full_image, xwidth, ywidth, maxval, fname);

  savePGM("test.pgm", image, xwidth, ywidth, row_per_proc, startrow_rank, 255, rank);


  if(image != NULL)
  {
    free(image);
    image = NULL;
  }

  // if(full_image != NULL)
  // {
  //   free(full_image);
  //   full_image = NULL;
  // }
  MPI_Finalize();

}

unsigned char count_live_neighbors(unsigned char* image, int row, int col, int xwidth, int ywidth)
{

  if((row - 1) < 0)
  {
    printf("Wrong row, minimum value is 1, actuak value is %d\n", row);
  }
  else if((row + 1) > (ywidth - 1))
  {
    printf("Wrong row, maximum value is %d, actuak value is %d\n", ywidth - 1, row);
  }

  int prev_col = -1;

  if(col == 0)
    prev_col = xwidth - 1;
  else
    prev_col = col - 1;
  
  int next_col = -1;

  if (col == (xwidth -1))
    next_col = 0;
  else
    next_col = col + 1;

  unsigned char sum = image[prev_col + (row - 1) * xwidth] + image[prev_col + row * xwidth] + image[prev_col + (row + 1) * xwidth];

  sum += image[col + (row - 1) * xwidth] + image[col + (row + 1) * xwidth];

  sum += image[next_col + (row - 1) * xwidth] + image[next_col + row * xwidth] + image[next_col + (row + 1) * xwidth];

  return sum;
}


int ordered_upgrade(unsigned char* image, int xwidth, int ywidth, int row, int col)
{
  unsigned char live_neighbors = count_live_neighbors(image, row, col, xwidth, ywidth);
  int idx = col + row * xwidth;

  if (live_neighbors == 2 || live_neighbors == 3)
  {
    image[idx] = 1;
  }
  else if ((live_neighbors >= 0 && live_neighbors < 2) || (live_neighbors > 3 && live_neighbors <=8))
  {
    image[idx] = 0;
  }
  else
  {
    printf("There is an issue with the count of the neighbors that are alive, they cannot be %d\n", (int)live_neighbors);
    return 1;
  }

  return 0;
  
}

void ordered_evolution(char* fname, int n, int s, int argc, char **argv)
{
  int rank; // ID of the actual process
  int n_procs; // Total number of porcesses 
  int mpi_provided_thread_level;

  int e = 0;

  int snap_idx = -1;
  int check = -1;


  if(s == 0){
    snap_idx = n;
  }
  else if(s > 0 && s <= n){
    snap_idx = s;
  }
  else{
    printf("Wrong value for \"s\" and/or \"n\", by default we will use s = n\n");
    snap_idx = n;
  }



  printf("Enter MPI environmrnt\n");
  check = MPI_Init_thread(&argc, &argv, MPI_THREAD_FUNNELED, &mpi_provided_thread_level);


  if(check != MPI_SUCCESS){
    printf("A problem arised while initialising MPI\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }
  if (mpi_provided_thread_level < MPI_THREAD_FUNNELED )
  {
    printf("A problem arised when asking for MPI_THREAD_FUNNELED levels\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }
  else
  {
    printf("Provided Thread level: %d\n", mpi_provided_thread_level);
  }

  // Get the rank of the process and the total number of processes 
  MPI_Comm_size(MPI_COMM_WORLD, &n_procs);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);

  int xwidth = -1, ywidth = -1, maxval = -1;

  read_header(&xwidth, &ywidth, &maxval, fname);

  unsigned char* original_image = (unsigned char*)malloc(xwidth * ywidth * sizeof(unsigned char));

  read_pgm_image(original_image, xwidth, ywidth, maxval, fname);

  // MPI_Barrier(MPI_COMM_WORLD);
  // if(rank == 0)
  // {
  //   printf("\nPlayground\n");
  //   for(int row = 0; row < ywidth; row++)
  //   {
  //     for(int col = 0; col < xwidth; col++)
  //     {
  //       printf("%d ", (int)original_image[col + row * xwidth]);
  //     }
  //     printf("\n");
  //   }
  // }
  // MPI_Barrier(MPI_COMM_WORLD);

  #ifdef TIME
    MPI_Barrier(MPI_COMM_WORLD); 
    printf("\n declare time variable\n");
    double start_time = -1, end_time = -1;
  #endif

  // distribute rows between MPI processes
  int row_per_procs = ywidth / n_procs; // rows for each process
  int remaining_rows_proc = ywidth % n_procs; // remaining rows
  if (rank < remaining_rows_proc)
      row_per_procs++;
  
  // printf("\nRank %d, rows per proc %d\n", rank, row_per_procs);

  const int cells_per_proc = row_per_procs * xwidth;

  int startrow_rank = rank * row_per_procs;
  if(rank >= remaining_rows_proc)
    startrow_rank += remaining_rows_proc;
    
  int endrow_rank = startrow_rank + row_per_procs;

  unsigned char* image = (unsigned char*)malloc((cells_per_proc + 2 * xwidth) * sizeof(unsigned char));


  printf("Initialise image\n");
  for(int col = 0; col < xwidth; col++)
  {
    // printf("row %d\n", startrow_rank);
    // The first row in image is either the previous row or the last row of original_image
    if(startrow_rank == 0)
      image[col] = original_image[col + (ywidth - 1) * xwidth];
    else
      image[col] = original_image[col + (startrow_rank - 1) * xwidth];
  }
  // Assign the cells to evolve
  for(int row = 1; row < (row_per_procs + 2 - 1); row++)
  {
    // printf("row %d\n", row);
    for(int col = 0; col < xwidth; col++)
      image[col + row * xwidth] = original_image[col + (row + startrow_rank - 1) * xwidth];
  }
  
  // Assign to the last row the value of the first row
  for(int col = 0; col < xwidth; col++)
  {
    if(endrow_rank == ywidth)
      image[col + (row_per_procs + 2 - 1) * xwidth] = original_image[col];
    else
      image[col + (row_per_procs + 2 - 1) * xwidth] = original_image[col + endrow_rank * xwidth];
  }

  printf("Image initialised\n");
   
  MPI_Barrier(MPI_COMM_WORLD);

  char hostname[10];
  if (gethostname(hostname, sizeof(hostname)) == 0)
      printf("I am process %d on node %s\n", rank, hostname);

  #ifdef TIME
    

    MPI_Barrier(MPI_COMM_WORLD);
    if (rank == 0)
    {
      printf("\n initialise time variable\n");
      start_time = MPI_Wtime();
      printf("Start time is %f\n", start_time);
    }
  #endif
    

  unsigned char first_row[xwidth], last_row[ywidth], first_row_recv[xwidth], last_row_recv[xwidth];

  // for(int col = 0; col < xwidth; col++)
  // {
  //   first_row[col] = image[col + xwidth];
  //   last_row[col] = aux_image[col + (row_per_procs - 2) * xwidth];
  // }

  

  const int prev_rank = (rank != 0) * (rank-1) + (rank == 0) * (n_procs-1);
  const int next_rank = (rank != n_procs-1) * (rank + 1);

  const int tag_send = rank * 10;
  const int tag_recv_prev = prev_rank * 10;
  const int tag_recv_next = next_rank * 10;

  MPI_Barrier(MPI_COMM_WORLD);


  printf("Initialise evolution\n");    
  for(int step = 0; step < n; step++)
  {



    if(rank == 0)
      printf("\nStep %d\n", step);

    MPI_Barrier(MPI_COMM_WORLD);


    for(int r = 0; r < n_procs; r++)
    {
      if(rank == r)
        printf("\n Start of r = %d\n", r);
      MPI_Barrier(MPI_COMM_WORLD);

      if(n_procs > 1)
      {
        if(r == 0)
        {
          if(rank == r)
            printf("\nr is %d\n", r);
          check = 0;

          MPI_Barrier(MPI_COMM_WORLD);

          if(rank == (n_procs - 1))
          {
            // Send last row to process 0
            printf("\n\tSend last row on process %d from process %d\n", next_rank, rank);
            check += MPI_Send(last_row, xwidth, MPI_UNSIGNED_CHAR, next_rank, tag_send, MPI_COMM_WORLD);
            // check += MPI_Send(last_row, xwidth, MPI_UNSIGNED_CHAR, 0, (n_procs - 1) * 10, MPI_COMM_WORLD);
            printf("\tSent on process %d from process %d\n", next_rank, rank); 
          }

          MPI_Barrier(MPI_COMM_WORLD);

          if(rank == 1)
          {
            // Send first row to process 0
            printf("\n\tSend first row on process %d from process %d\n", prev_rank, rank);
            check += MPI_Send(first_row, xwidth, MPI_UNSIGNED_CHAR, prev_rank, tag_send, MPI_COMM_WORLD);
            // check += MPI_Send(first_row, xwidth, MPI_UNSIGNED_CHAR, 0, 1 * 10, MPI_COMM_WORLD);
            printf("\tSent on process %d from process %d\n", prev_rank, rank);
          }

          MPI_Barrier(MPI_COMM_WORLD);

          if(rank == 0)
          {
            // Receive first row from process n_procs - 1
            printf("\n\tReceive first row on process %d from process %d\n", rank, prev_rank);
            check += MPI_Recv(first_row_recv, xwidth, MPI_UNSIGNED_CHAR, prev_rank, tag_recv_prev, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            // check += MPI_Recv(first_row_recv, xwidth, MPI_UNSIGNED_CHAR, n_procs - 1, (n_procs - 1) * 10, MPI_COMM_WORLD, MPI_STATUS_IGNORE); 
            printf("\tReceived on process %d\n", rank);

            MPI_Barrier(MPI_COMM_WORLD);

            // Receive last row from process 1
            printf("\n\tReceive last row on process %d from process %d\n", rank, next_rank);
            check += MPI_Recv(last_row_recv, xwidth, MPI_UNSIGNED_CHAR, next_rank, tag_recv_next, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            // check += MPI_Recv(last_row_recv, xwidth, MPI_UNSIGNED_CHAR, 1, 1 * 10, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            printf("\tReceivd on process %d\n", rank);
            
          }
          MPI_Barrier(MPI_COMM_WORLD);
          printf("\nEnd of r = %d\n", r);
          if(check > 0)
          {
            printf("There was a problem with send and receive in rank %d\n", rank);
            MPI_Abort(MPI_COMM_WORLD, 1);
          }

        }

        MPI_Barrier(MPI_COMM_WORLD);
        
        if(r == (n_procs - 1))
        {
          check = 0;
          if(rank == r)
            printf("\nr is %d\n", r);
          MPI_Barrier(MPI_COMM_WORLD);

          printf("\nr is %d\n", r);
          if(rank == (n_procs - 2))
          {
            //Send last row to process n_procs - 1
            printf("\n\tSend last row on process %d from process %d\n", next_rank, rank);
            check += MPI_Send(last_row, xwidth, MPI_UNSIGNED_CHAR, next_rank, tag_send, MPI_COMM_WORLD);
            printf("\tSent on process %d from process %d\n", next_rank, rank); 
          }
          MPI_Barrier(MPI_COMM_WORLD);
          if(rank == 0)
          {
            // Send first row to process n_procs - 1
            printf("\n\tSend first row on process %d from process %d\n", prev_rank, rank);
            check += MPI_Send(first_row, xwidth, MPI_UNSIGNED_CHAR, prev_rank, tag_send, MPI_COMM_WORLD);
            printf("\tSent on process %d from process %d\n", prev_rank, rank); 
          }

          MPI_Barrier(MPI_COMM_WORLD);
          
          if(rank == (n_procs - 1))
          {
            // Receive first row from process n_procs - 2
            printf("\nReceive first row on process %d from process %d\n", rank, prev_rank);
            check += MPI_Recv(first_row_recv, xwidth, MPI_UNSIGNED_CHAR, prev_rank, tag_recv_prev, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            printf("Received on process %d from process %d\n", rank, prev_rank);

            MPI_Barrier(MPI_COMM_WORLD);

            // Receive last row from process 0
            printf("\nReceive last row on process %d from process %d\n", rank, next_rank);
            check += MPI_Recv(last_row_recv, xwidth, MPI_UNSIGNED_CHAR, next_rank, tag_recv_next, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            printf("Received on process %d from process %d\n", rank, next_rank);
          }
          
          MPI_Barrier(MPI_COMM_WORLD);
          
          
          if(check > 0)
          {
            printf("There was a problem with send and receive in rank %d\n", rank);
            MPI_Abort(MPI_COMM_WORLD, 1);
          }
        }
        // If we only have 2 sockets, the operation is finished
        
        MPI_Barrier(MPI_COMM_WORLD);

        if(n_procs > 2 && (r >=1 && r < (n_procs - 1)))
        {
          check = 0;
          if(rank == r)
            printf("\nr is %d\n", r);
          MPI_Barrier(MPI_COMM_WORLD);

          if(rank == (r - 1))
          {
            // Send last row to next rank
            printf("\n\tSend last row on process %d from process %d\n", next_rank, rank);
            check += MPI_Send(last_row, xwidth, MPI_UNSIGNED_CHAR, next_rank, tag_send, MPI_COMM_WORLD);
            printf("\tSent from process %d\n", rank);
          }

          MPI_Barrier(MPI_COMM_WORLD);
          
          if(rank == (r + 1))
          {
            // Send first row to previous rank
            printf("\n\tSend first row on process %d from process %d\n", prev_rank, rank);
            check += MPI_Send(first_row, xwidth, MPI_UNSIGNED_CHAR, prev_rank, tag_send, MPI_COMM_WORLD);
            printf("\tSent from process %d\n", rank);
          }

          MPI_Barrier(MPI_COMM_WORLD);

          if(rank == r)
          {
            // Receive first row from process r - 1
            printf("\n\tReceive first row on process %d from process %d\n", rank, prev_rank);
            check += MPI_Recv(first_row_recv, xwidth, MPI_UNSIGNED_CHAR, prev_rank, tag_recv_prev, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            printf("\tReceived on process %d\n", rank);

            MPI_Barrier(MPI_COMM_WORLD);
            // Receive last row from process r + 1

            printf("\n\tReceive last row on process %d from process %d\n", rank, next_rank);
            check += MPI_Recv(last_row_recv, xwidth, MPI_UNSIGNED_CHAR, next_rank, tag_recv_next, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            printf("\tReceived on process %d\n", rank);
            
          }
          MPI_Barrier(MPI_COMM_WORLD);
        }
       
      }

      else if(n_procs == 1)
      {
        //Simply assign row 1 to row ywidth -1
        // and row ywidth - 2 to row 0
        MPI_Barrier(MPI_COMM_WORLD);
        for(int col = 0; col < xwidth; col++)
        {
          image[col + (ywidth - 1) * xwidth] = image[col + xwidth];
          image[col] = image[col + (ywidth - 2) * xwidth];
        }
      }
      else
      {
        printf("Error, there cannot be less that one process\n");
        MPI_Abort(MPI_COMM_WORLD, 1);
      }

      MPI_Barrier(MPI_COMM_WORLD);
      if(rank == r)
      {
        MPI_Barrier(MPI_COMM_WORLD);
        printf("\nUpgrade for step %d rank %d\n", step, rank);
        for (int row = 1; row < (row_per_procs + 2 - 2); row++)
        {
          for(int col = 0; col < xwidth; col++)
          {
            // Evolve a portion of the matrix
            check = ordered_upgrade(image, xwidth, ywidth, row, col);
            
            if(check == 1)
            {
              printf("Ther was an issue while upgrading\n");
              MPI_Abort(MPI_COMM_WORLD, 0);
            }
          }
        }
        printf("Upgraded for step %d rank %d\n", step, rank);
      }

      
      MPI_Barrier(MPI_COMM_WORLD);
      
      if(rank == r)
        printf("\nEnd of send/receive operations\n");
    }
    printf("\nEnd of process cycle\n");
    // End of cycle on the processes
    
    // MPI_Barrier(MPI_COMM_WORLD);

    // printf("\nAllocate to new image\n");
    // unsigned char* aux_image = (unsigned char*)malloc(xwidth * row_per_procs * sizeof(unsigned char));
    // printf("Allocated\n");

    // printf("\nAssign to new image\n");
    // for(int idx = 0; idx < row_per_procs; idx++)
    //   aux_image[idx] = image[idx + xwidth];
    // printf("Assigned\n");
    
    // // MPI_Barrier(MPI_COMM_WORLD);

    // printf("\nGathering images\n");
    // gather_images(aux_image, original_image, xwidth, ywidth, n_procs, rank);
    // printf("Gathered\n");

    // free(aux_image);

    // MPI_Barrier(MPI_COMM_WORLD);
    // if(rank == 1)
    // {
      
    //   printf("\nSnapshot part %d\n", rank);
    //   for(int row = 1; row <= row_per_procs; row++)
    //   {
    //     for(int col = 0; col < xwidth; col++)
    //     {
    //       printf("%d ", (int)image[col + row * xwidth]);
    //     }
    //     printf("\n");
    //   }
    // }
    // MPI_Barrier(MPI_COMM_WORLD);
    // if(rank == 1)
    // {
      
    //   printf("\nSnapshot part %d\n", rank);
    //   for(int row = 1; row < row_per_procs; row++)
    //   {
    //     for(int col = 0; col < xwidth; col++)
    //     {
    //       printf("%d ", (int)image[col + row * xwidth]);
    //     }
    //     printf("\n");
    //   }
    // }
    // MPI_Barrier(MPI_COMM_WORLD);
    // if(rank == 2)
    // {
      
    //   printf("\nSnapshot part %d\n", rank);
    //   for(int row = 1; row < row_per_procs; row++)
    //   {
    //     for(int col = 0; col < xwidth; col++)
    //     {
    //       printf("%d ", (int)image[col + row * xwidth]);
    //     }
    //     printf("\n");
    //   }
    // }
    // MPI_Barrier(MPI_COMM_WORLD);
    // if(rank == 3)
    // {
    //   printf("\nSnapshot part %d\n", rank);
    //   for(int row = 1; row < row_per_procs; row++)
    //   {
    //     for(int col = 0; col < xwidth; col++)
    //     {
    //       printf("%d ", (int)image[col + row * xwidth]);
    //     }
    //     printf("\n");
    //   }
    // }

    // MPI_Barrier(MPI_COMM_WORLD);

    // free(aux_image);

    // Save a snapshot every s steps
    // if((step + 1)%snap_idx == 0)
    // {
    //   if(rank == 0)
    //   {
        
    //     printf("\nSnapshot\n");
    //     for(int row = 0; row < ywidth; row++)
    //     {
    //       for(int col = 0; col < xwidth; col++)
    //       {
    //         printf("%d ", (int)original_image[col + row * xwidth]);
    //       }
    //       printf("\n");
    //     }
      
    //     // printf("Save Snapshot\n");
    //     // MPI_Barrier(MPI_COMM_WORLD);
    //     // save_snapshot(image, xwidth, row_per_procs, 1, "snapshot", n_threads, step);
    //     // printf("Snapshot saved\n");
    //   }
    // }

    printf("\nEnd of step %d\n", step);






  }
  // End of evolution
  printf("\nEnd of evolution\n");

  free(image);
  free(original_image);


  


  
  #ifdef TIME
    printf("\nEnter time environment\n");
    MPI_Barrier(MPI_COMM_WORLD);
    if (rank == 0)
    {
      printf("\nCalculate elapsed time\n");
      printf("\n start time is: %f\n", start_time);
      end_time = MPI_Wtime();
      printf("End time is %f\n", end_time);

      double elapsed_time = end_time - start_time;
      printf("Elapsed time is %f\n", elapsed_time);

      FILE* datafile;
      datafile = fopen("times.csv", "a");

      if(datafile == NULL)
        printf("There was a problem while trying to open the file\n");

      fprintf(datafile, "%d,%d,%d,%d,%d,%lf\n", e, xwidth, n, n_procs, elapsed_time);
      fclose(datafile);
    }

  #endif


  printf("\nfinalize MPI\n");
  MPI_Finalize();

  printf("\nMPI finalized\n");
}
