#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <omp.h>
#include <mpi.h>
#include "parallel_header_v3.h"

#include<unistd.h>

void write_pgm_image(unsigned char *image, int xsize, int ysize, int maxval, char* filename){

        FILE* image_file; 
        image_file = fopen(filename, "wb");
        if(image_file == NULL)
        {
          printf("There was an error while opening the image file\n");
        }
        fprintf(image_file, "P5\n# generated by\n# Lisa Da Vinchie\n%d %d %d\n", xsize, ysize, maxval);
    
    
        for (int i=0; i < xsize * ysize; i++){
            fprintf(image_file, "%c", image[i] * 255);
        }

        fclose(image_file);
}

void read_header(int *xsize, int *ysize, int *maxval, char *filename){

    FILE *file = fopen(filename, "rb");
    if(!file){
        perror("Error opening file\n");
    }

    char MagicN[2];

    if(fread(MagicN, 1, 2, file) != 2 || MagicN[0] != 'P' || MagicN[1] != '5'){
        printf("Not a PGM P5 image\n");
        fclose(file);
    }

    // int xsize = -1, ysize = -1, color_maxval = -1;
    char line[50];
    while(fgets(line, sizeof(line), file)){
        if(line[0] == '#'){
            continue;
        }
        else if(sscanf(line, "%d %d\n%d", xsize, ysize, maxval) == 3){
            break;
        } 
    }


    if(*maxval > 255){
        printf("Maxval is too big\n");
        fclose(file);
    }

    else{
        sscanf(line, "%d %d %d\n", xsize, ysize, maxval);
    }
    fclose(file);
}

void read_pgm_image(unsigned char* image, int xsize, int ysize, int maxval, char* filename){
    int elements = 0;

    FILE *file = fopen(filename, "rb");
    if(!file){
        perror("Error opening file\n");
    }

    char MagicN[2];

    if(fread(MagicN, 1, 2, file) != 2 || MagicN[0] != 'P' || MagicN[1] != '5'){
        printf("Not a PGM P5 image\n");
        fclose(file);
    }


    char line[50];
    while(fgets(line, sizeof(line), file)){
        if(line[0] == '#'){
            continue;
        }
        else if(sscanf(line, "%d %d\n%d", &xsize, &ysize, &maxval) == 3){
            break;
        } 
    }


    if(maxval > 255){
        printf("Maxval is too big\n");
        fclose(file);
    }

    else{
        sscanf(line, "%d %d %d\n", &xsize, &ysize, &maxval);
    }
    elements = fread(image, sizeof(unsigned char), xsize * ysize, file);

    for(int idx = 0; idx < xsize * ysize; idx++){
        image[idx] = image[idx]/255;
    }

    fclose(file);
}



unsigned char count_live_neighbors(unsigned char* image, int row, int col, int xwidth, int ywidth)
{

  if(row < 1)
  {
    printf("Wrong row, minimum value is 1, actual value is %d\n", row);
    MPI_Abort(MPI_COMM_WORLD, 1);
  }
  else if(row > (ywidth + 2 - 2))
  {
    printf("Wrong row, maximum value is %d, actual value is %d\n", ywidth - 2, row);
    MPI_Abort(MPI_COMM_WORLD, 1);
  }

  int prev_col = -1;

  if(col == 0)
    prev_col = xwidth - 1;
  else
    prev_col = col - 1;
  
  int next_col = -1;

  if (col == (xwidth -1))
    next_col = 0;
  else
    next_col = col + 1;

  unsigned char sum = image[prev_col + (row - 1) * xwidth] + image[prev_col + row * xwidth] + image[prev_col + (row + 1) * xwidth];

  sum += image[col + (row - 1) * xwidth] + image[col + (row + 1) * xwidth];

  sum += image[next_col + (row - 1) * xwidth] + image[next_col + row * xwidth] + image[next_col + (row + 1) * xwidth];

  return sum;
}







int static_upgrade(unsigned char* aux_image, unsigned char* image, int xwidth, int ywidth, int row, int col)
{

  int idx = col + row * xwidth;
  unsigned char live_neighbors = count_live_neighbors(image, row, col, xwidth, ywidth);
  if (live_neighbors == 2 || live_neighbors == 3){
    aux_image[idx] = 1;
  }
  else if(live_neighbors < 0 || live_neighbors > 8){
    printf("There is an issue with the count of the neighbors that are alive, they cannot be %d\n", (int)live_neighbors);
    return 1;
  }
  else{
    aux_image[idx] = 0;
  }

  return 0;
}



void savePGM(const char* filename, unsigned char* image, int xwidth, int rows_per_proc, int maxval)
{
    FILE* file = fopen(filename, "wb");
    if (file)
    {
        fprintf(file, "P5\n# generated by\n# Lisa Da Vinchie\n%d %d %d\n", xwidth, rows_per_proc, maxval);

        for (int i=0; i < xwidth * rows_per_proc; i++){
            fprintf(file, "%c", image[i] * 255);
        }
        // fwrite(image, sizeof(unsigned char), xwidth * rows_per_proc, file);
        fclose(file);
    }
}

void save_snapshot(unsigned char* image, int xwidth, int rows_per_proc, int maxval, char* snap_title, int first_index, int image_idx)
{
  char title[50];
  snprintf(title, 50, "%s_%d_%05d.pgm", snap_title, first_index, image_idx);
  savePGM(title, image, xwidth, rows_per_proc, maxval);
}




void static_evolution(char* fname, int n, int s, int argc, char **argv)
{
  int rank; // ID of the actual process
  int n_procs; // Total number of porcesses
  int thread_id; // ID of the actual thread 
  int n_threads; // Total number of threads
  int mpi_provided_thread_level;

  int e = 1;

  int check = -1; // variable used to check the status of MPI functions

  //printf("Define at which steps a snapshot will be taken\n");
  int snap_idx = -1;
  if(s == 0){
    snap_idx = n;
  }
  else if(s > 0 && s <= n){
    snap_idx = s;
  }
  else{
    printf("Wrong value for \"s\" and/or \"n\", by default we will use s = n\n");
    snap_idx = n;
  }

  check = MPI_Init_thread(&argc, &argv, MPI_THREAD_FUNNELED, &mpi_provided_thread_level);


  if(check != MPI_SUCCESS){
    printf("A problem arised while initialising MPI\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }
  if (mpi_provided_thread_level < MPI_THREAD_FUNNELED )
  {
    printf("A problem arised when asking for MPI_THREAD_FUNNELED levels\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }
  else
  {
    printf("Provided Thread level: %d\n", mpi_provided_thread_level);
  }


  // Get the rank of the process and the total number of processes 
  MPI_Comm_size(MPI_COMM_WORLD, &n_procs);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);

  #ifdef TIME
    printf("Declare time variable\n");
    double start_time;
  #endif

  // Initialise variables to store matrix dimensions and color maximum value
  int xwidth = -1, ywidth = -1, maxval = -1;    

  // Read header to get xwidth, ywidth and maxval
  read_header(&xwidth, &ywidth, &maxval, fname);

  MPI_Barrier(MPI_COMM_WORLD);
  
  // Allocate matrix to store playground
  unsigned char* original_image = (unsigned char*)malloc(xwidth * ywidth * sizeof(unsigned char));

  // Read playground and assign it to original_image
  read_pgm_image(original_image, xwidth, ywidth, maxval, fname);

  // if(rank == 0)
  // {
  //   printf("Playground \n");
    
  //   int idx = 0;
  //   for(int row = 0; row < ywidth; row++)
  //   {
  //     for(int col = 0; col < xwidth; col++)
  //     {
  //       printf("%d ", (int)original_image[idx]);
  //       idx++;
  //     }
  //     printf("\n");
  //   }
  // }


  // distribute rows between MPI processes
  int row_per_procs = ywidth / n_procs; // rows for each process
  int remaining_rows_proc = ywidth % n_procs; // remaining rows
  if (rank < remaining_rows_proc)
      row_per_procs++;
  
  
  // Total cells for each process
  const int cells_per_proc = row_per_procs * xwidth;

  unsigned char* image = (unsigned char*)malloc((cells_per_proc + 2 * xwidth) * sizeof(unsigned char));

  // Assign the rows of original_image to image
  int startrow_rank = rank * row_per_procs;
  if(rank >= remaining_rows_proc)
    startrow_rank += remaining_rows_proc;
    
  int endrow_rank = startrow_rank + row_per_procs;

  // printf("Startrow %d, endrow %d\n", startrow_rank, endrow_rank);


  for(int col = 0; col < xwidth; col++)
  {
    // printf("row %d\n", startrow_rank);
    // The first row in image is either the previous row or the last row of original_image
    if(startrow_rank == 0)
      image[col] = original_image[col + (ywidth - 1) * xwidth];
    else
      image[col] = original_image[col + (startrow_rank - 1) * xwidth];
  }
  // Assign the cells to evolve
  for(int row = 1; row < (row_per_procs + 2 - 1); row++)
  {
    // printf("row %d\n", row);
    for(int col = 0; col < xwidth; col++)
      image[col + row * xwidth] = original_image[col + (row + startrow_rank - 1) * xwidth];
  }
  
  // Assign to the last row the value of the first row
  for(int col = 0; col < xwidth; col++)
  {
    if(endrow_rank == ywidth)
      image[col + (row_per_procs + 2 - 1) * xwidth] = original_image[col];
    else
      image[col + (row_per_procs + 2 - 1) * xwidth] = original_image[col + endrow_rank * xwidth];
  }

  // MPI_Barrier(MPI_COMM_WORLD);
  // printf("\nPartial matrix rank %d\n", rank);
  // for(int row = 0; row < (row_per_procs + 2); row++)
  // {
  //   for(int col = 0; col < xwidth; col++)
  //     printf("%d\t", (int)image[col + row * xwidth]);
  //   printf("\n");
  // }
  // printf("\n");

  unsigned char* aux_image = (unsigned char*)malloc((cells_per_proc + 2 * xwidth) * sizeof(unsigned char));

  // Initialise auxiliary image to image
  for(int idx = 0; idx < cells_per_proc; idx++)
    aux_image[idx] = image[idx];


 #pragma omp parallel
  {
    #pragma omp master
    {
      n_threads = omp_get_num_threads();
      
      if(rank == 0)
      {
        printf("\nNumber of processes: %d\nOpenMP threads per process: %d\n\n", n_procs, n_threads);
      }
    }
    // Get the id of the actual thread
    int thread_id = omp_get_thread_num();

    char hostname[10];

    if (gethostname(hostname, sizeof(hostname)) == 0) {
      printf("I am thread %d of rank %d of node %s\n", thread_id, rank, hostname);
    }
    else
    {
      printf("Error getting hostname");
    }


    #pragma omp barrier

    int cells_per_thread = cells_per_proc / n_threads;
    int remaninig_cells_thread = cells_per_proc% n_threads;

    if (thread_id < remaninig_cells_thread)
      cells_per_thread++;

    //printf("rank %d, thread %d, cells per thread %d\n", rank, thread_id, cells_per_thread);

    int startidx_thread = thread_id * cells_per_thread;

    if(thread_id >= remaninig_cells_thread)
      startidx_thread += remaninig_cells_thread;

    startidx_thread += xwidth;


    int endidx_thread = startidx_thread + cells_per_thread;

    //printf("rank %d, thread %d, startidx %d, endidx %d\n", rank, thread_id, startidx_thread, endidx_thread);


    #pragma omp barrier
    #pragma omp master
    {

      #ifdef TIME
          MPI_Barrier(MPI_COMM_WORLD);
          if (rank == 0)
          {
            start_time = omp_get_wtime();
          }
      #endif
    }


    #pragma omp barrier

    for(int step = 0; step < n; step++)
    {
      #pragma omp barrier
      printf("start of cycle %d for thread %d of rank %d\n", step, thread_id, rank);

      printf("Evolve thread %d of rank %d\n", thread_id, rank);
      for(int threadidx = startidx_thread; threadidx < endidx_thread; threadidx++)
      {
        int row = threadidx / xwidth;
        int col = threadidx % xwidth;
        // printf("idx %d, row %d, col %d\n", threadidx, row, col);

        int check = static_upgrade(aux_image, image, xwidth, ywidth, row, col);

        if(check == 1)
        {
          printf("There was a problem while upgrading");
          MPI_Abort(MPI_COMM_WORLD, 1);
        }
      }
      printf("Evolved thread %d of rank %d\n", thread_id, rank);

     
      printf("Assign evolved cells to image in thread %d of rank %d\n", thread_id, rank);
      // Assign the evolved cells to image
      for(int idx = startidx_thread; idx < endidx_thread; idx++)
        image[idx] = aux_image[idx - xwidth];
      
      printf("Assigned evolved cells to image in thread %d of rank %d\n", thread_id, rank);
      
      

      //Communicate the updated rows between sockets
      #pragma omp barrier
      #pragma omp master
      {
        if(n_procs == 1)
        {
          //Simply assign row 1 to row (ywidth - 1)th
          //and row (ywidth - 2)th to row 0

          for(int col = 0; col < xwidth; col++)
          {
            image[col + (ywidth - 1)] = image[col + xwidth];
            image[col] = image[col + (ywidth - 2) * xwidth];
          }
        }
        else
        {
          // Use MPI communicators
          unsigned char first_row[xwidth], last_row[ywidth], first_row_recv[xwidth], last_row_recv[xwidth];

          for(int col = 0; col < xwidth; col++)
          {
            first_row[col] = aux_image[col];
            last_row[col] = aux_image[col + (row_per_procs - 1) * xwidth];
          }

          

          const int prev_rank = (rank != 0) * (rank-1) + (rank == 0) * (n_procs-1);
          const int next_rank = (rank != n_procs-1) * (rank + 1);

          const int tag_send = rank * 10;
          const int tag_recv_prev = prev_rank * 10;
          const int tag_recv_next = next_rank * 10;

          // MPI_Barrier(MPI_COMM_WORLD);

          printf("communicate rank %d\n", rank);
          if(rank % 2 == 0)
          {
            printf("Send on process %d\n", rank);
            int check = MPI_Send(first_row, xwidth, MPI_UNSIGNED_CHAR, prev_rank, tag_send, MPI_COMM_WORLD);
            if(check > 0)
              printf("Error in send from rank %d to rank %d", rank, prev_rank);
            printf("Sent on process %d\n", rank);
            
            printf("Receive on process %d\n", rank);  
            check = MPI_Recv(last_row_recv, xwidth, MPI_UNSIGNED_CHAR, next_rank, tag_recv_next, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            if(check > 0)
              printf("Error in recv from rank %d to rank %d", next_rank, rank); 
            printf("Received on process %d\n", rank); 

            printf("Send on process %d\n", rank);  
            check = MPI_Send(last_row, xwidth, MPI_UNSIGNED_CHAR, next_rank, tag_send, MPI_COMM_WORLD);
            if(check > 0)
              printf("Error in send from rank %d to rank %d", rank, prev_rank);
            printf("Sent on process %d\n", rank);

            printf("Receive on process %d\n", rank); 
            check = MPI_Recv(first_row_recv, xwidth, MPI_UNSIGNED_CHAR, prev_rank, tag_recv_prev, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            if(check > 0)
              printf("Error in recv from rank %d to rank %d", next_rank, rank);
            printf("Receivd on process %d\n", rank); 
          }
          else
          {
            // printf("Receive on process %d\n", rank); 
            int check = MPI_Recv(last_row_recv, xwidth, MPI_UNSIGNED_CHAR, next_rank, tag_recv_next, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            // printf("Received on process %d\n", rank);

            // printf("Send on process %d\n", rank); 
            check += MPI_Send(first_row, xwidth, MPI_UNSIGNED_CHAR, prev_rank, tag_send, MPI_COMM_WORLD);
            // printf("Sent on process %d\n", rank);

            // printf("Receive on process %d\n", rank);
            check += MPI_Recv(first_row_recv, xwidth, MPI_UNSIGNED_CHAR, prev_rank, tag_recv_prev, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
            // printf("Received on process %d\n", rank);

            // printf("Send on process %d\n", rank);
            check += MPI_Send(last_row, xwidth, MPI_UNSIGNED_CHAR, next_rank, tag_send, MPI_COMM_WORLD); 
            // printf("Sent on process %d\n", rank);
            
            if(check > 0)
              printf("Error in communication in rank %d", rank);  
          }

          printf("communicated rank %d\n", rank);

          // MPI_Barrier(MPI_COMM_WORLD);

        
          for(int col = 0; col < xwidth; col++)
          {
            image[col] = first_row_recv[col];
            image[col + (row_per_procs + 2 - 1) * xwidth] = last_row_recv[col];
          }
        }

      } 
      // End of master process
      


      // Save a snapshot every s steps
    //   if((step + 1)%snap_idx == 0)
    //   {
    //     #pragma omp barrier
    //     #pragma omp master
    //     {
    //       printf("Save Snapshot\n");
    //       MPI_Barrier(MPI_COMM_WORLD);
    //       save_snapshot(image, xwidth, row_per_procs, 1, "snapshot", n_threads, step);
    //       printf("Snapshot saved\n");
    //     }
    //   }
    //   printf("End of cycle %d for thread %d of rank %d\n", step, thread_id, rank);

    }
    // End of evolution




    // Save results
    #pragma omp barrier
    #pragma omp master
    {
      #ifdef TIME

        MPI_Barrier(MPI_COMM_WORLD);

        if (rank == 0)
        {
          double elapsed_time = omp_get_wtime() - start_time;

          FILE* datafile;
          datafile = fopen("times.csv", "a");

          if(datafile == NULL){
            printf("There was a problem while trying to open the file\n");
          }

          fprintf(datafile, "%d,%d,%d,%d,%d,%lf\n", e, xwidth, n, n_procs, n_threads, elapsed_time);
          fclose(datafile);
        }

      #endif

    }
  }
  // End of OpenMP parallel region

  if(image != NULL){
    free(image);
    image = NULL;
  }


  if(aux_image != NULL){
    free(aux_image);
    aux_image = NULL;
  }

  if(original_image != NULL){
    free(original_image);
    original_image = NULL;
  }

  MPI_Finalize();
}
