#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <getopt.h>

#include <time.h>

#include "serial_header.h"
// #include <omp.h>
// #include <mpi.h>


// Definitions for the argument getting part
#define INIT 1
#define RUN  2

#define K_DFLT 100

#define ORDERED 0
#define STATIC  1


// char fname_deflt[] = "game_of_life.pgm";

int   action = 0;
int   k      = K_DFLT;
int   e      = ORDERED;
int   n      = 10000;
int   s      = 1;
char *fname  = NULL;



// void write_pgm_image(char *image, int maxval, int xsize, int ysize, const char *image_name)
// /*
//  * image        : a pointer to the memory region that contains the image
//  * maxval       : either 255 or 65536
//  * xsize, ysize : x and y dimensions of the image
//  * image_name   : the name of the file to be written
//  *
//  */
// {
//   FILE* image_file; 
//   image_file = fopen(image_name, "wb"); 
  
//   // Writing header
//   // The header's format is as follows, all in ASCII.
//   // "whitespace" is either a blank or a TAB or a CF or a LF
//   // - The Magic Number (see below the magic numbers)
//   // - the image's width
//   // - the height
//   // - a white space
//   // - the image's height
//   // - a whitespace
//   // - the maximum color value, which must be between 0 and 65535
//   //
//   // if he maximum color value is in the range [0-255], then
//   // a pixel will be expressed by a single byte; if the maximum is
//   // larger than 255, then 2 bytes will be needed for each pixel
//   //

// //   int color_depth = 1 + ( maxval > 255 );

//   fprintf(image_file, "P5\n# generated by\n# put here your name\n%d %d\n%d\n", xsize, ysize, maxval);
  
  
//   for (int i=0; i<xsize*ysize; i++){
//     fprintf(image_file, "%c", image[i]);
//   }

//     // fwrite( image, sizeof(bool), xsize*ysize, image_file);

//   fclose(image_file); 
//   return ;

//   /* ---------------------------------------------------------------

//      TYPE    MAGIC NUM     EXTENSION   COLOR RANGE
//            ASCII  BINARY

//      PBM   P1     P4       .pbm        [0-1]
//      PGM   P2     P5       .pgm        [0-255]
//      PPM   P3     P6       .ppm        [0-2^16[
  
//   ------------------------------------------------------------------ */
// }

// void read_pgm_image(unsigned char **image, int *maxval, int *xsize, int *ysize, const char *image_name)
// /*
//  * image        : a pointer to the pointer that will contain the image
//  * maxval       : a pointer to the int that will store the maximum intensity in the image
//  * xsize, ysize : pointers to the x and y sizes
//  * image_name   : the name of the file to be read
//  *
//  */
// {
//   FILE* image_file; 
//   image_file = fopen(image_name, "r"); 

//   // *image = NULL;
//   *xsize = *ysize = *maxval = 0;
  
//   char    MagicN[3];
//   char   *line = NULL;
//   size_t  k, n = 0;


  
//   // get the Magic Number
//   k = fscanf(image_file, "%2s%*c", MagicN);

//   printf("Magic number read\n");
//   // skip all the comments
//   k = getline( &line, &n, image_file);
//   printf("Comments skipped\n");
//   while ( (k > 0) && (line[0]=='#') )
//     k = getline( &line, &n, image_file);

//   if (k > 0)
//     {
//       k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
//       if ( k < 3 )
// 	fscanf(image_file, "%d%*c", maxval);
//     }
//   else
//     {
//       *maxval = -1;         // this is the signal that there was an I/O error
// 			    // while reading the image header
//       free( line );
//       return;
//     }
//   free( line );
  
//   int color_depth = 1 + ( *maxval > 255 );
//   unsigned int size = *xsize * *ysize * color_depth;
  
//   if ( (*image = (char*)malloc( size )) == NULL )
//     {
//       fclose(image_file);
//       *maxval = -2;         // this is the signal that memory was insufficient
//       *xsize  = 0;
//       *ysize  = 0;
//       return;
//     }
  
//   if ( fread( *image, 1, size, image_file) != size )
//     {
//       free( image );
//       image   = NULL;
//       *maxval = -3;         // this is the signal that there was an i/o error
//       *xsize  = 0;
//       *ysize  = 0;
//     }
    
//     fclose(image_file);
//   return;
// }

// void random_playground(char* image, int xsize, int ysize)
// {
//     int idx = 0;
//     srand(time(NULL));
//     for (int y = 0; y < ysize; y++){
//         for (int x = 0; x < xsize; x++){
//             // image[idx] = (char)((double)rand()/(double)RAND_MAX+0.5);
//             image[idx] = (char)((int)rand()%2);
//             // printf("%d ", (int)image[idx]);
//             printf("%c ", image[idx] + 48);
//             idx++;
//         }
//     printf("\n");
//     }
// }




// void read_image(){

// }
int main ( int argc, char **argv )
{

//Get the arguments, copy of Tornatore's "get_args.c" program
  int action = 0;
  char *optstring = "irk:e:f:n:s:";

  int c;
  while ((c = getopt(argc, argv, optstring)) != -1) {
    switch(c) {
      
    case 'i':
      action = INIT; break;
      
    case 'r':
      action = RUN; break;
      
    case 'k':
      k = atoi(optarg); break;

    case 'e':
      e = atoi(optarg); break;

    case 'f':
      fname = (char*)malloc(sizeof(optarg)+1 );
      sprintf(fname, "%s", optarg );
      break;

    case 'n': //number of steps to be calculated
      n = atoi(optarg); break;

    case 's': //every how many steps a dump is saved
      s = atoi(optarg);break;

    default :
      printf("argument -%c not known\n", c ); break;
    }
  }
  printf("action = %d\nk = %d\ne = %d\nf = %s\nn_steps = %d\nn_dump = %d\n", action, k, e, fname, n, s);

  // char *destination_folder = "./snapshots"; //Where the results will be saved
  if(action == INIT){

    int xwidth = k;
    int ywidth = k;
    int maxval = 1;

    unsigned char* image = NULL;
    image = (unsigned char*)malloc(xwidth * ywidth * sizeof(unsigned char));

    random_playground(image, xwidth, ywidth);
    write_pgm_image(image, xwidth, ywidth, maxval, fname);

    printf("\nInitial playground\n");
    int idx = 0;
      for (int y = 0; y < ywidth; y++){
          for (int x = 0; x < xwidth; x++){
              printf("%d ", (int)image[idx]);
              idx++;
          }
      printf("\n");
    }

    free(image);

  }

else if(action == RUN){
  
  int xwidth = -1, ywidth = -1, maxval = -1;
  read_header(&xwidth, &ywidth, &maxval, fname);

  // printf("x = %d, y = %d, maxval = %d\n", xwidth, ywidth, maxval);

  unsigned char* image = NULL;
  image = (unsigned char*)malloc(xwidth * ywidth * sizeof(unsigned char));

  read_pgm_image(image, xwidth, ywidth, maxval, fname);


  int idx = 0;

  printf("initial playground\n");
  for (int y = 0; y < ywidth; y++){
    for (int x = 0; x < xwidth; x++){
        printf("%d ", (int)image[idx]);
        idx++;
    }
    printf("\n");
  }

  // unsigned char live_n = count_live_neighbors(image, 0, 0, xwidth, ywidth);

  // printf("Live neighbors: %d\n", (int)live_n);
  printf("\n"); 
  if(e == ORDERED){
    ordered_evolution(image, xwidth, ywidth, n, s, "snap_test");
  }
  else if(e == STATIC){
    static_evolution(image, xwidth, ywidth, n, s, "snap_test");
  }
  else{
    printf("Invalid value for flag \"-e\"\n");
    return 1;
  }

  free(image);
 
}

else{
  printf("Invalid value for variable \"action\"\n");
  return 1;
}
return 0;
}