#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <omp.h>
#include <mpi.h>
#include "parallel_header.h"

#include<unistd.h>

void write_pgm_image(unsigned char *image, int xsize, int ysize, int maxval, char* filename){

        FILE* image_file; 
        image_file = fopen(filename, "wb");
        if(image_file == NULL)
        {
          printf("There was an error while opening the image file\n");
        }
        fprintf(image_file, "P5\n# generated by\n# Lisa Da Vinchie\n%d %d %d\n", xsize, ysize, maxval);
    
    
        for (int i=0; i < xsize * ysize; i++){
            fprintf(image_file, "%c", image[i] * 255);
        }

        fclose(image_file);
}

void read_header(int *xsize, int *ysize, int *maxval, char *filename){

    FILE *file = fopen(filename, "rb");
    if(!file){
        perror("Error opening file\n");
    }

    char MagicN[2];

    if(fread(MagicN, 1, 2, file) != 2 || MagicN[0] != 'P' || MagicN[1] != '5'){
        printf("Not a PGM P5 image\n");
        fclose(file);
    }

    // int xsize = -1, ysize = -1, color_maxval = -1;
    char line[50];
    while(fgets(line, sizeof(line), file)){
        if(line[0] == '#'){
            continue;
        }
        else if(sscanf(line, "%d %d\n%d", xsize, ysize, maxval) == 3){
            break;
        } 
    }


    if(*maxval > 255){
        printf("Maxval is too big\n");
        fclose(file);
    }

    else{
        sscanf(line, "%d %d %d\n", xsize, ysize, maxval);
    }
    fclose(file);
}

void read_pgm_image(unsigned char* image, int xsize, int ysize, int maxval, char* filename){
    int elements = 0;

    FILE *file = fopen(filename, "rb");
    if(!file){
        perror("Error opening file\n");
    }

    char MagicN[2];

    if(fread(MagicN, 1, 2, file) != 2 || MagicN[0] != 'P' || MagicN[1] != '5'){
        printf("Not a PGM P5 image\n");
        fclose(file);
    }

    // int xsize = -1, ysize = -1, color_maxval = -1;
    char line[50];
    while(fgets(line, sizeof(line), file)){
        if(line[0] == '#'){
            continue;
        }
        else if(sscanf(line, "%d %d\n%d", &xsize, &ysize, &maxval) == 3){
            break;
        } 
    }


    if(maxval > 255){
        printf("Maxval is too big\n");
        fclose(file);
    }

    else{
        sscanf(line, "%d %d %d\n", &xsize, &ysize, &maxval);
    }
    elements = fread(image, sizeof(unsigned char), xsize * ysize, file);

    for(int idx = 0; idx < xsize * ysize; idx++){
        image[idx] = image[idx]/255;
    }

    fclose(file);
}

unsigned char count_live_neighbors(unsigned char* image, int row, int col, int xwidth, int ywidth){
  
  int row_vals[3]; 
  int col_vals[3];

  row_vals[1] = row;
  col_vals[1] = col;

  if(row == 0){
    row_vals[0] = ywidth - 1;
    row_vals[2] = row + 1;
  }
  else if(row == ywidth - 1){
    row_vals[0] = row - 1;
    row_vals[2] = 0;
  }
  else if(row > 0 && row < (ywidth - 1)){
    row_vals[0] = row - 1;
    row_vals[2] = row + 1; 
  }
  else{
    printf("Something is wrong with the row value, it cannot be %d\n", row);
  }

  if(col == 0){
    col_vals[0] = xwidth - 1;
    col_vals[2] = col + 1;
  }
  else if(col == xwidth - 1){
    col_vals[0] = col - 1;
    col_vals[2] = 0;
  }
  else if(col > 0 && col < (xwidth - 1)){
    col_vals[0] = col - 1;
    col_vals[2] = col + 1; 
  }
  else{
    printf("Something is wrong with the col value, it cannot be %d\n", col);
  }

  unsigned char sum = 0;
  for(int j = 0; j < 3; j++){
    for(int i = 0; i < 3; i++){
      if (i==1 && j==1){
        continue;
      }
      else{
        sum = sum + image[col_vals[i] + row_vals[j] * xwidth];
      }
    }
  }

return sum;
}



// int ordered_upgrade(unsigned char* image, int xwidth, int ywidth, int row, int col)
// {
//   //calculate status of cell in [row][col]
//   int idx = col + row * xwidth;

//   unsigned char live_neighbors = count_live_neighbors(image, row, col, xwidth, ywidth);
//   if (live_neighbors == 2 || live_neighbors == 3){
//     image[idx] = 1;
//   }
//   else if(live_neighbors < 0 || live_neighbors > 8){
//     printf("There is an issue with the count of the neighbors that are alive, they cannot be %d\n", (int)live_neighbors);
//     return 1;
//   }
//   else{
//     image[idx] = 0;
//   }
//   return 0;
// }



// void ordered_evolution(unsigned char* image, int xsize, int ysize, int n, int s, char *destination_folder)
// {
//   int rank; // ID of the actual process
//   int n_procs; // Total number of porcesses
//   int thread_id; // ID of the actual thread 
//   int n_threads; // Total number of threads
//   int mpi_provided_thread_level;

//   int e = 0;

//   int snap_idx = -1;
//   int check = -1;

//   if(s == 0){
//     snap_idx = n;
//   }
//   else if(s > 0 && s <= n){
//     snap_idx = s;
//   }
//   else{
//     printf("Wrong value for \"s\" and/or \"n\", by default we will use s = n\n");
//     snap_idx = n;
//   }



//   check = MPI_Init_thread(&argc, &argv, MPI_THREAD_FUNNELED, &mpi_provided_thread_level);


//   if(check != MPI_SUCCESS){
//     printf("A problem arised while initialising MPI\n");
//     MPI_Abort(MPI_COMM_WORLD, 1);
//   }
//   if (mpi_provided_thread_level < MPI_THREAD_FUNNELED )
//   {
//     printf("A problem arised when asking for MPI_THREAD_FUNNELED levels\n");
//     MPI_Abort(MPI_COMM_WORLD, 1);
//   }
//   else
//   {
//     printf("Provided Thread level: %d\n", mpi_provided_thread_level);
//   }

//   // Get the rank of the process and the total number of processes 
//   MPI_Comm_size(MPI_COMM_WORLD, &n_procs);
//   MPI_Comm_rank(MPI_COMM_WORLD, &rank);

//   #ifdef TIME
//     //printf("Declare time variable\n");
//     double start_time;
//   #endif

//   int xwidth = -1, ywidth = -1, maxval = -1;

//   read_header(&xwidth, &ywidth, &maxval, fname);

//   unsigned char* image = (unsigned char*)malloc(xwidth * ywidth * sizeof(unsigned char));

//   read_pgm_image(image, xwidth, ywidth, maxval, fname);

//   // distribute rows between MPI processes
//   int row_per_procs = ywidth / n_procs; // rows for each process
//   int remaining_rows_proc = ywidth % n_procs; // remaining rows
//   if (rank < remaining_rows_proc)
//       row_per_procs++;

//   const int cells_per_proc = row_per_procs * xwidth;

//   char hostname[10];



   
//   #pragma omp parallel
//   {
//     int thread_id = omp_get_thread_num();

//     if (gethostname(hostname, sizeof(hostname)) != 0)
//     {
//         printf("Error getting hostname");
//         hostname = "error";
//     }

//     printf("I am thread %d on socket %d on node %s\n", thread_id, rank, hostname);

//     #pragma omp barrier
//     #pragma omp master
//     {
//       #ifdef TIME
//           MPI_Barrier(MPI_COMM_WORLD);
//           if (rank == 0)
//               start_time = omp_get_wtime();
//       #endif
//     }
//     #pragma omp barrier

    
//     for(int step = 0; step < n; step++)
//     {
//       #pragma omp barrier
//       #pragma omp master
//       {
//         MPI_Barrier(MPI_COMM_WORLD);

//         int socket = 0;
//         int old_socket = -1;

//         for(int row = 0; row < ywidth; row++)
//         {
//           #pragma omp barrier
//           MPI_Barrier(MPI_COMM_WORLD);

//           if(rank == socket)
//           {
//             for (int col = 0; col < xwidth; col++)
//             {
//               int check = ordered_upgrade(unsigned char* image, int xwidth, int ywidth, int row, int col) 
              
//               if(check == 1)
//               {
//                 printf("Ther was an issue while upgrading\n");
//                 MPI_Abort(MPI_COMM_WORLD, 0);
//               }
//             }
//             //End of col cycle
//           }

//           #pragma omp barrier
//           MPI_Barrier(MPI_COMM_WORLD);

//           old_socket = socket;

//           socket++;

//           if(socket == n_procs)
//             socket = 0;


//           if(rank == old_socket)
//           {
//             //Send message to new process
//             check = MPI_Send(image, xwidth * ywidth, MPI_UNSIGNED_CHAR, socket, 3, MPI_COMM_WORLD);
//             if(check != MPI_SUCCESS)
//             {
//               printf("There was a problem while sending a message from process %d to process %d\n", old_socket, socket);
//               MPI_Abort(MPI_COMM_WORLD, 1);
//             }
//           }

//           else if(rank == socket)
//           {
//             // Receive message from old process
//             check = MPI_Recv(image, xwidth * ywidth, MPI_UNSIGNED_CHAR, old_socket, 3, MPI_COMM_WORLD, MP_STATUS_IGNORE);
//             if(check != MPI_SUCCESS)
//             {
//               printf("There was a problem while receiving a message from process %d on process %d\n", old_socket, socket);
//               MPI_Abort(MPI_COMM_WORLD, 1);
//             }
//           }


//         }
//         // End of row cycle

//         if((step + 1)%snap_idx == 0)
//         {
//           save_snapshot(image, xwidth, ywidth, maxval, "snapshot", n_threads, step);
//           // printf("\nTaking snapshot\n");
//           // char title[50];
//           // snprintf(title, 50, "%s_%d.pbm", destination_folder, step);
//           // printf("%s\n",title);

//           // printf("Writing image\n");
//           // write_pgm_image(image, xsize, ysize, maxval, title);
//           // printf("Image written\n");
//         }
//       }
//       // End of master region
//     }
//     // End of evolution

//     #pragma omp barrier
//     #pragma omp master
//     {
//       #ifdef TIME

//         MPI_Barrier(MPI_COMM_WORLD);

//         if (rank == 0)
//         {
//           double elapsed_time = omp_get_wtime() - start_time;

//           FILE* datafile;
//           datafile = fopen("times.csv", "a");

//           if(datafile == NULL){
//             printf("There was a problem while trying to open the file\n");
//           }

//           fprintf(datafile, "%d,%d,%d,%d,%d,%lf\n", e, xwidth, n, n_procs, n_threads, elapsed_time);
//           fclose(datafile);
//         }

//       #endif
//     }

//   }
//   //end of OpenMP region

//   MPI_Finalize();

// }



int static_upgrade(unsigned char* image, unsigned char* original_image, int xwidth, int ywidth, int row, int col)
{
  int idx = col + row * xwidth;
  unsigned char live_neighbors = count_live_neighbors(original_image, row, col, xwidth, ywidth);
  if (live_neighbors == 2 || live_neighbors == 3){
    image[idx] = 1;
  }
  else if(live_neighbors < 0 || live_neighbors > 8){
    printf("There is an issue with the count of the neighbors that are alive, they cannot be %d\n", (int)live_neighbors);
    return 1;
  }
  else{
    image[idx] = 0;
  }

  return 0;
}

void save_snapshot(unsigned char* image, int xwidth, int ywidth, int maxval, char* snap_title, int first_index, int image_idx)
{
  char title[50];
  snprintf(title, 50, "%s_%d_%05d.pgm", snap_title, first_index, image_idx);
  write_pgm_image(image, xwidth, ywidth, maxval, title);
}

void print_matrix(unsigned char* image, int xwidth, int ywidth)
{
  int idx = 0;
  for(int x = 0; x < xwidth; x++)
  {
    for(int y = 0; y < ywidth; y++)
    {
      printf("%d ", (int)image[idx]);
      idx++;
    }
    printf("\n");
  }
}

void gather_images(unsigned char* partial_image, unsigned char* full_image, int xwidth, int ywidth, int n_procs, int rank)
{

  // Calculate displacement and counts, that will be necessary for gathering the images
  if(rank == 0){
      int displacement[n_procs]; // Start index of every pack of data in the full matrix
      int counts[n_procs]; // Number of cells to gather from each process
      int check = -1; // Variable used to check wether MPI_Gatherv was executed successfully or not

        for(int r = 0; r < n_procs; r++)
        {
          int rows_per_proc = ywidth / n_procs; // rows per process
          int remaining_rows = ywidth % n_procs;

          if(r < remaining_rows)
            rows_per_proc++;
          
          counts[r] = rows_per_proc * xwidth;

          displacement[r] = r * rows_per_proc;

          if(r >= remaining_rows)
            displacement[r] += remaining_rows; 
          
          displacement[r] = displacement[r] * xwidth;

        }


        check = MPI_Gatherv(partial_image, counts[0], MPI_UNSIGNED_CHAR, full_image, counts, displacement, MPI_UNSIGNED_CHAR, 0, MPI_COMM_WORLD);
        
        if(check != MPI_SUCCESS)
        {
          printf("Error while gathering in rank %d\n", rank);
          MPI_Abort(MPI_COMM_WORLD, 1);
        } 
    }

    else{
      int check = -1; // Variable used to check wether MPI_Gatherv was executed successfully or not

      int rows_per_proc = ywidth / n_procs; // rows per process
      int remaining_rows = ywidth % n_procs;

      if(rank < remaining_rows)
        rows_per_proc++;
      
      int cells_per_proc = rows_per_proc * xwidth; // Number of cells generated by this process

      check = MPI_Gatherv(partial_image, cells_per_proc, MPI_UNSIGNED_CHAR, NULL, NULL, NULL, MPI_UNSIGNED_CHAR, 0, MPI_COMM_WORLD);
        
      if(check != MPI_SUCCESS)
        printf("Error while gathering in rank %d\n", rank);
 
    }
}



void initialise_playground(int k, int maxval, char* fname, int argc, char **argv)
{

  // initialise_playground(k, maxval, fname, argc, argv);

  int xwidth = k;
  int ywidth = k;

  int rank; // ID of the actual process
  int n_procs; // Total number of porcesses
  int thread_id; // ID of the actual thread 
  int n_threads; // Total number of threads
  int mpi_provided_thread_level;

  int check = -1; // variable used to check the status of MPI functions

  printf("Start MPI environment\n");
  check = MPI_Init_thread(&argc, &argv, MPI_THREAD_FUNNELED, &mpi_provided_thread_level);


  if(check != MPI_SUCCESS){
    printf("A problem arised while initialising MPI\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }
  if (mpi_provided_thread_level < MPI_THREAD_FUNNELED )
  {
    printf("A problem arised when asking for MPI_THREAD_FUNNELED levels\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }
  // else
  // {
  //   if(rank == 0)
  //     printf("Provided Thread level: %d\n", mpi_provided_thread_level);
  // }


  // Get the rank of the process and the total number of processes 
  MPI_Comm_size(MPI_COMM_WORLD, &n_procs);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);


  // Divide rows between the processes
  int row_per_proc = ywidth / n_procs;
  int remaining_rows_per_proc = ywidth % n_procs;

  if(rank < remaining_rows_per_proc)
    row_per_proc++;
  

  const int cells_per_proc = row_per_proc * xwidth;
  
  // Allocate memory for a partial image
  unsigned char* image = NULL;
  image = (unsigned char*)malloc(cells_per_proc * sizeof(unsigned char));

  if(image == NULL){
    printf("Memory allocation of \"image\" failed\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }

  // Create a random playground in parallel
  #pragma omp parallel
  {
    // get the total number of threads
    #pragma omp master
    {
      n_threads = omp_get_num_threads();
      printf("\nSockets: %d\nThreads: %d\n", n_procs, n_threads);
    }

    // Get the number of the actual thread
    thread_id = omp_get_num_threads();
    

    srand(time(NULL) + rank);
    
    // Create a random playground
    #pragma omp for schedule(static)
      for (int idx = 0; idx < cells_per_proc; idx++){
        image[idx] = (unsigned char)((int)rand()%2);
      }
  }

  MPI_Barrier(MPI_COMM_WORLD);

  // Allocate memory to gather the results of the images that were generated separately
  unsigned char* full_image = (unsigned char*)malloc(xwidth * ywidth * sizeof(unsigned char));

  // Gather images into full image
  gather_images(image, full_image, xwidth, ywidth, n_procs, rank);
  

  // Save playground
  if(rank == 0)
    write_pgm_image(full_image, xwidth, ywidth, maxval, fname);


  if(image != NULL)
  {
    free(image);
    image = NULL;
  }

  if(full_image != NULL)
  {
    free(full_image);
    full_image = NULL;
  }
  MPI_Finalize();

}



void static_evolution(char* fname, int n, int s, int argc, char **argv)
{
  int rank; // ID of the actual process
  int n_procs; // Total number of porcesses
  int thread_id; // ID of the actual thread 
  int n_threads; // Total number of threads
  int mpi_provided_thread_level;

  int e = 1;

  int check = -1; // variable used to check the status of MPI functions

  //printf("Define at which steps a snapshot will be taken\n");
  int snap_idx = -1;
  if(s == 0){
    snap_idx = n;
  }
  else if(s > 0 && s <= n){
    snap_idx = s;
  }
  else{
    printf("Wrong value for \"s\" and/or \"n\", by default we will use s = n\n");
    snap_idx = n;
  }

  check = MPI_Init_thread(&argc, &argv, MPI_THREAD_FUNNELED, &mpi_provided_thread_level);


  if(check != MPI_SUCCESS){
    printf("A problem arised while initialising MPI\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }
  if (mpi_provided_thread_level < MPI_THREAD_FUNNELED )
  {
    printf("A problem arised when asking for MPI_THREAD_FUNNELED levels\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }
  else
  {
    printf("Provided Thread level: %d\n", mpi_provided_thread_level);
  }


  // Get the rank of the process and the total number of processes 
  MPI_Comm_size(MPI_COMM_WORLD, &n_procs);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);


  // Get the number of OpenMP threads for each process
  #pragma omp parallel
  {
    #pragma omp master
    {
      n_threads = omp_get_num_threads();
      printf("\nSockets: %d\nThreads: %d\n", n_procs, n_threads);

      if(rank == 0)
      {
        printf("\nNumber of processes: %d\nOpenMP threads per process: %d\n\n", n_procs, n_threads);
      }
    }
  }

  #ifdef TIME
    printf("Declare time variable\n");
    double start_time;
  #endif

  // Initialise variables to store matrix dimensions and color maximum value
  int xwidth = -1, ywidth = -1, maxval = -1;    

  // Read header to get xwidth, ywidth and maxval
  read_header(&xwidth, &ywidth, &maxval, fname);

  MPI_Barrier(MPI_COMM_WORLD);
  
  // Allocate matrix to store playground
  unsigned char* original_image = (unsigned char*)malloc(xwidth * ywidth * sizeof(unsigned char));

  // Read playground and assign it to original_image
  read_pgm_image(original_image, xwidth, ywidth, maxval, fname);

  // distribute rows between MPI processes
  int row_per_procs = ywidth / n_procs; // rows for each process
  int remaining_rows_proc = ywidth % n_procs; // remaining rows
  if (rank < remaining_rows_proc){
      row_per_procs++;
    }
  
  // Total cells for each process
  const int cells_per_proc = row_per_procs * xwidth;

  // Allocate auxiliary matrix to evolve the playground
  unsigned char* image = (unsigned char*)malloc(cells_per_proc * sizeof(unsigned char));


  #pragma omp parallel
  {
    // Get the id of the actual thread
    int thread_id = omp_get_thread_num();

    char hostname[256];

    if (gethostname(hostname, sizeof(hostname)) == 0) {
        // printf("Running on node: %s\n", hostname);
    }
    else
    {
        printf("Error getting hostname");
    }

    // printf("I am thread %d on socket %d on node %s\n", thread_id, rank, hostname);

    // distribute cells between threads
    int cells_per_thread = cells_per_proc / n_threads; // rows for each process
    int remaining_cells_thread = cells_per_proc % n_threads; // remaining rows

    if (thread_id < remaining_cells_thread)
      cells_per_thread++;

    // Define the start and end indices of each piece of matrix
    int startidx = thread_id * cells_per_thread;

    if(thread_id >= remaining_cells_thread)
      startidx += remaining_cells_thread;

    int endidx = startidx + cells_per_thread - 1;


    #pragma omp barrier
    #pragma omp master
    {

      #ifdef TIME
          MPI_Barrier(MPI_COMM_WORLD);
          if (rank == 0)
          {
              start_time = omp_get_wtime();
          }
      #endif
    }

    #pragma omp barrier


    for(int step = 0; step < n; step++)
    {
      #pragma omp barrier

      for(int idx = startidx; idx <= endidx; idx++)
      {
        //initialise image to 200 as a form of check
        image[idx] = 200;

        // Retrieve row ann column indexes knowing the cell index
        int row = idx / xwidth;
        int col = idx % xwidth;

        int check = static_upgrade(image, original_image, xwidth, ywidth, row, col);

        if(check == 1)
        {
          printf("Ther was an issue while upgrading\n");
          MPI_Abort(MPI_COMM_WORLD, 0);
        }
      }

      #pragma omp barrier
      #pragma omp master
      {
        MPI_Barrier(MPI_COMM_WORLD);

        // Gather images into full image
        gather_images(image, original_image, xwidth, ywidth, n_procs, rank);

      }

      
      #pragma omp barrier


      // Save a snapshot every s steps
      if((step + 1)%snap_idx == 0)
      {
        #pragma omp master
        {
          MPI_Barrier(MPI_COMM_WORLD); 
          if(rank == 0)
            save_snapshot(original_image, xwidth, ywidth, maxval, "snapshot", n_threads, step);
        }
      }


    }// End of evolution

    #pragma omp barrier

    // Save results
    #pragma omp master
    {
      #ifdef TIME

        MPI_Barrier(MPI_COMM_WORLD);

        if (rank == 0)
        {
          double elapsed_time = omp_get_wtime() - start_time;

          FILE* datafile;
          datafile = fopen("times.csv", "a");

          if(datafile == NULL){
            printf("There was a problem while trying to open the file\n");
          }

          fprintf(datafile, "%d,%d,%d,%d,%d,%lf\n", e, xwidth, n, n_procs, n_threads, elapsed_time);
          fclose(datafile);
        }

      #endif
    }
  }
  // End of OpenMP parallel region

  if(image != NULL){
    free(image);
    image = NULL;
  }

  if(original_image != NULL){
    free(original_image);
    original_image = NULL;
  }

  MPI_Finalize();
}

unsigned char count_live_neighbors_v2(unsigned char* image, int row, int col, int xwidth, int ywidth)
{

  if((row - 1) < 0)
  {
    printf("Wrong row, minimum value is 1, actuak value is %d\n", row);
  }
  else if((row + 1) > (ywidth - 1))
  {
    printf("Wrong row, maximum value is %d, actuak value is %d\n", ywidth - 1, row);
  }

  int prev_col = -1;

  if(col == 0)
    prev_col = xwidth - 1;
  else
    prev_col = col - 1;
  
  int next_col = -1;

  if (col == (xwidth -1))
    next_col = 0;
  else
    next_col = col + 1;

  unsigned char sum = image[prev_col + (row - 1) * xwidth] + image[prev_col + row * xwidth] + image[prev_col + (row + 1) * xwidth];

  sum += image[col + (row - 1) * xwidth] + image[col + (row + 1) * xwidth];

  sum += image[next_col + (row - 1) * xwidth] + image[next_col + row * xwidth] + image[next_col + (row + 1) * xwidth];

  return sum;
}

int static_upgrade_v2(unsigned char* image, int xwidth, int ywidth, int row, int col)
{
  int idx = col + row * xwidth;
  unsigned char live_neighbors = count_live_neighbors(image, row, col, xwidth, ywidth);
  if (live_neighbors == 2 || live_neighbors == 3){
    image[idx] = 1;
  }
  else if(live_neighbors < 0 || live_neighbors > 8){
    printf("There is an issue with the count of the neighbors that are alive, they cannot be %d\n", (int)live_neighbors);
    return 1;
  }
  else{
    image[idx] = 0;
  }

  return 0;
}







void static_evolution_v2(char* fname, int n, int s, int argc, char **argv)
{
  int rank; // ID of the actual process
  int n_procs; // Total number of porcesses
  int thread_id; // ID of the actual thread 
  int n_threads; // Total number of threads
  int mpi_provided_thread_level;

  int e = 1;

  int check = -1; // variable used to check the status of MPI functions

  //printf("Define at which steps a snapshot will be taken\n");
  int snap_idx = -1;
  if(s == 0){
    snap_idx = n;
  }
  else if(s > 0 && s <= n){
    snap_idx = s;
  }
  else{
    printf("Wrong value for \"s\" and/or \"n\", by default we will use s = n\n");
    snap_idx = n;
  }

  check = MPI_Init_thread(&argc, &argv, MPI_THREAD_FUNNELED, &mpi_provided_thread_level);


  if(check != MPI_SUCCESS){
    printf("A problem arised while initialising MPI\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }
  if (mpi_provided_thread_level < MPI_THREAD_FUNNELED )
  {
    printf("A problem arised when asking for MPI_THREAD_FUNNELED levels\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }
  else
  {
    printf("Provided Thread level: %d\n", mpi_provided_thread_level);
  }


  // Get the rank of the process and the total number of processes 
  MPI_Comm_size(MPI_COMM_WORLD, &n_procs);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);

  #ifdef TIME
    printf("Declare time variable\n");
    double start_time;
  #endif

  // Initialise variables to store matrix dimensions and color maximum value
  int xwidth = -1, ywidth = -1, maxval = -1;    

  // Read header to get xwidth, ywidth and maxval
  read_header(&xwidth, &ywidth, &maxval, fname);

  MPI_Barrier(MPI_COMM_WORLD);
  
  // Allocate matrix to store playground
  unsigned char* original_image = (unsigned char*)malloc(xwidth * ywidth * sizeof(unsigned char));

  // Read playground and assign it to original_image
  read_pgm_image(original_image, xwidth, ywidth, maxval, fname);

  // if(rank == 0)
  // {
  //   printf("Playground \n");
    
  //   int idx = 0;
  //   for(int row = 0; row < ywidth; row++)
  //   {
  //     for(int col = 0; col < xwidth; col++)
  //     {
  //       printf("%d ", (int)original_image[idx]);
  //       idx++;
  //     }
  //     printf("\n");
  //   }
  // }

  MPI_Barrier(MPI_COMM_WORLD);

  // distribute rows between MPI processes
  int row_per_procs = ywidth / n_procs; // rows for each process
  int remaining_rows_proc = ywidth % n_procs; // remaining rows
  if (rank < remaining_rows_proc)
      row_per_procs++;
  
  
  // Total cells for each process
  const int cells_per_proc = row_per_procs * xwidth;

  unsigned char* image = (unsigned char*)malloc((cells_per_proc + 2 * xwidth) * sizeof(unsigned char));

  // Assign initial value to image
  if(rank == 0)
  {
    printf("Rows per procs = %d\n", row_per_procs);
    // Assign to the first row of image the last row of the full image
    printf("row 0\n");
    for(int col = 0; col < xwidth; col++)
    {
      image[col] = original_image[col + (ywidth - 1) * xwidth];
    }
    // Assign the cells to evolve
    for(int row = 1; row < (row_per_procs + 2 - 1); row++)
    {
      printf("row %d\n", row);
      for(int col = 0; col < xwidth; col++)
        image[col + row * xwidth] = original_image[col + (row - 1) * xwidth];
    }
    // Assign to the last row the value of the neighboring row
    printf("row %d\n", (row_per_procs + 2 - 1));
    for(int col = 0; col < xwidth; col++)
    {
      image[col + (row_per_procs + 2 - 1) * xwidth] = original_image[col + row_per_procs * xwidth];
    }

    // MPI_Barrier(MPI_COMM_WORLD);

    // printf("Partial matrix %d\n", rank);

    // for(int row = 0; row < (row_per_procs + 2); row++)
    // {
    //   for(int col = 0; col < xwidth; col++)
    //     printf("%d ", (int)image[col + row * xwidth]);
    //   printf("\n");
    // }
    // printf("\n");
  }

  MPI_Barrier(MPI_COMM_WORLD);

  if(rank == 1)
  {
    int startrow = rank * row_per_procs;
    if(rank >= remaining_rows_proc)
      startrow += remaining_rows_proc;
    
    int endrow = startrow + row_per_procs;

    printf("Start row: %d, end row: %d\n", startrow, endrow);

    printf("Rows per procs = %d\n", row_per_procs);
    // Assign to the first row of image the last row of the full image
    printf("row %d\n", startrow);
    for(int col = 0; col < xwidth; col++)
    {
      image[col] = original_image[col + (startrow - 1) * xwidth];
    }
    // Assign the cells to evolve
    for(int row = 1; row < (row_per_procs + 2 - 1); row++)
    {
      printf("row %d\n", row);
      for(int col = 0; col < xwidth; col++)
        image[col + row * xwidth] = original_image[col + (row + startrow - 1) * xwidth];
    }
    // Assign to the last row the value of the first row
    printf("row 0\n");
    for(int col = 0; col < xwidth; col++)
    {
      image[col + (row_per_procs + 2 - 1) * xwidth] = original_image[col];
    }

    // MPI_Barrier(MPI_COMM_WORLD);

    // printf("Partial matrix %d\n", rank);
    // for(int row = 0; row < (row_per_procs + 2); row++)
    // {
    //   for(int col = 0; col < xwidth; col++)
    //     printf("%d ", (int)image[col + row * xwidth]);
    //   printf("\n");
    // }
    // printf("\n");
  }

 unsigned char* partial_image = (unsigned char*)malloc(row_per_procs * xwidth * sizeof(unsigned char));

 #pragma omp parallel
  {
    #pragma omp master
      n_threads = omp_get_num_threads();

    if(rank == 0)
    {
      printf("\nNumber of processes: %d\nOpenMP threads per process: %d\n\n", n_procs, n_threads);
    }
    // Get the id of the actual thread
    int thread_id = omp_get_thread_num();

    char hostname[256];

    if (gethostname(hostname, sizeof(hostname)) == 0) {
        // printf("Running on node: %s\n", hostname);
    }
    else
    {
        printf("Error getting hostname");
    }

    // printf("I am thread %d on socket %d on node %s\n", thread_id, rank, hostname);

    int rows_per_thread = row_per_procs / n_threads; // rows for each thread
    int remaining_rows_thread = row_per_procs % n_threads; // remaining rows

    if (thread_id < remaining_rows_thread)
      rows_per_thread++;

    // Define the start and end row of each piece of matrix
    int startrow = thread_id * rows_per_thread;

    if(thread_id >= remaining_rows_thread)
      startrow += remaining_rows_thread;

    int endrow = startrow + rows_per_thread;

    // printf("thread %d of rank %d, startrow: %d, endrow: %d\n", thread_id, rank, startrow, endrow);



    #pragma omp barrier
    #pragma omp master
    {

      #ifdef TIME
          MPI_Barrier(MPI_COMM_WORLD);
          if (rank == 0)
          {
              start_time = omp_get_wtime();
          }
      #endif
    }

    #pragma omp barrier


    for(int step = 0; step < n; step++)
    {
      #pragma omp barrier

      for(int row = (startrow + 1); row < (endrow - 1); row++)
      {
        for(int col = 0; col < xwidth; col++)
        {
          // unsigned char liven = count_live_neighbors_v2(image, row, col, xwidth, ywidth);

          // if(rank == 1)
          //   printf("%d ", (int)liven);
          check = static_upgrade_v2(image, xwidth, ywidth, row, col);

          if(check == 1)
          {
            printf("There was a problem while upgrading");
          }
        }
        if(rank == 1)
          printf("\n");
      }
      #pragma omp barrier

      #pragma omp master
      {
        MPI_Barrier(MPI_COMM_WORLD);
        if(rank == 1)
        {
          int row_per_procs = ywidth / n_procs; // rows for each process
          int remaining_rows_proc = ywidth % n_procs; // remaining rows
          printf("Result image\n");
          if (rank < remaining_rows_proc)
              row_per_procs++;
          for(int row = 0; row < row_per_procs; row++)
          {
            for(int col = 0; col < xwidth; col++)
            {
              partial_image[col + row * xwidth] = image[col + (row + 1) * xwidth];
              printf("%d ", (int)partial_image[col + row * xwidth]);
            }
            printf("\n");
          }
        }
      }
      
      // gather_images(partial_image, original_image, xwidth, ywidth, n_procs, rank);

    }

      }
  // End of OpenMP parallel region
    free(partial_image);
  if(image != NULL){
    free(image);
    image = NULL;
  }

  if(original_image != NULL){
    free(original_image);
    original_image = NULL;
  }

  MPI_Finalize();
}

void static_evolution_test(char* fname, int n, int s, int argc, char **argv)
{
  int rank; // ID of the actual process
  int n_procs; // Total number of porcesses
  int thread_id; // ID of the actual thread 
  int n_threads; // Total number of threads
  int mpi_provided_thread_level;

  int e = 1;

  int check = -1; // variable used to check the status of MPI functions

  //printf("Define at which steps a snapshot will be taken\n");
  int snap_idx = -1;
  if(s == 0){
    snap_idx = n;
  }
  else if(s > 0 && s <= n){
    snap_idx = s;
  }
  else{
    printf("Wrong value for \"s\" and/or \"n\", by default we will use s = n\n");
    snap_idx = n;
  }

  check = MPI_Init_thread(&argc, &argv, MPI_THREAD_FUNNELED, &mpi_provided_thread_level);


  if(check != MPI_SUCCESS){
    printf("A problem arised while initialising MPI\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }
  if (mpi_provided_thread_level < MPI_THREAD_FUNNELED )
  {
    printf("A problem arised when asking for MPI_THREAD_FUNNELED levels\n");
    MPI_Abort(MPI_COMM_WORLD, 1);
  }
  else
  {
    printf("Provided Thread level: %d\n", mpi_provided_thread_level);
  }


  // Get the rank of the process and the total number of processes 
  MPI_Comm_size(MPI_COMM_WORLD, &n_procs);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);


  // Get the number of OpenMP threads for each process
  #pragma omp parallel
  {
    #pragma omp master
    {
      n_threads = omp_get_num_threads();
      printf("\nSockets: %d\nThreads: %d\n", n_procs, n_threads);

      if(rank == 0)
      {
        printf("\nNumber of processes: %d\nOpenMP threads per process: %d\n\n", n_procs, n_threads);
      }
    }
  }

  #ifdef TIME
    printf("Declare time variable\n");
    double start_time;
  #endif

  // Initialise variables to store matrix dimensions and color maximum value
  int xwidth = -1, ywidth = -1, maxval = -1;    

  // Read header to get xwidth, ywidth and maxval
  read_header(&xwidth, &ywidth, &maxval, fname);

  MPI_Barrier(MPI_COMM_WORLD);
  
  // Allocate matrix to store playground
  unsigned char* original_image = (unsigned char*)malloc(xwidth * ywidth * sizeof(unsigned char));

  // Read playground and assign it to original_image
  read_pgm_image(original_image, xwidth, ywidth, maxval, fname);

  // distribute rows between MPI processes
  int row_per_procs = ywidth / n_procs; // rows for each process
  int remaining_rows_proc = ywidth % n_procs; // remaining rows
  if (rank < remaining_rows_proc){
      row_per_procs++;
    }
  
  // Total cells for each process
  const int cells_per_proc = row_per_procs * xwidth;

  // Allocate auxiliary matrix to evolve the playground
  unsigned char* image = (unsigned char*)malloc(cells_per_proc * sizeof(unsigned char));


  #pragma omp parallel
  {
    // Get the id of the actual thread
    int thread_id = omp_get_thread_num();

    char hostname[256];

    if (gethostname(hostname, sizeof(hostname)) == 0) {
        // printf("Running on node: %s\n", hostname);
    }
    else
    {
        printf("Error getting hostname");
    }

    printf("I am thread %d on socket %d on node %s\n", thread_id, rank, hostname);

    // distribute cells between threads
    int cells_per_thread = cells_per_proc / n_threads; // rows for each process
    int remaining_cells_thread = cells_per_proc % n_threads; // remaining rows

    if (thread_id < remaining_cells_thread)
      cells_per_thread++;

    // Define the start and end indices of each piece of matrix
    int startidx = thread_id * cells_per_thread;

    if(thread_id >= remaining_cells_thread)
      startidx += remaining_cells_thread;

    int endidx = startidx + cells_per_thread - 1;



    #pragma omp barrier


    for(int step = 0; step < n; step++)
    {
      
      #pragma omp barrier
      #pragma omp master
      {

        #ifdef TIME
            MPI_Barrier(MPI_COMM_WORLD);
            if (rank == 0)
            {
                start_time = omp_get_wtime();
            }
        #endif
      }

      for(int idx = startidx; idx <= endidx; idx++)
      {
        //initialise image to 200 as a form of check
        image[idx] = 200;

        // Retrieve row ann column indexes knowing the cell index
        int row = idx / xwidth;
        int col = idx % xwidth;

        int check = static_upgrade(image, original_image, xwidth, ywidth, row, col);

        if(check == 1)
        {
          printf("Ther was an issue while upgrading\n");
          MPI_Abort(MPI_COMM_WORLD, 0);
        }
      }

          #pragma omp barrier

      // Save results
      #pragma omp master
      {
        #ifdef TIME

          MPI_Barrier(MPI_COMM_WORLD);

          if (rank == 0)
          {
            double elapsed_time = omp_get_wtime() - start_time;

            FILE* datafile;
            datafile = fopen("times.csv", "a");

            if(datafile == NULL){
              printf("There was a problem while trying to open the file\n");
            }

            fprintf(datafile, "%d,%d,%d,%d,%d,%lf\n", e, xwidth, n, n_procs, n_threads, elapsed_time);
            fclose(datafile);
          }

        #endif
      }

      #pragma omp barrier
      #pragma omp master
      {
        MPI_Barrier(MPI_COMM_WORLD);

        // Gather images into full image
        gather_images(image, original_image, xwidth, ywidth, n_procs, rank);

      }

      
      #pragma omp barrier


      // Save a snapshot every s steps
      if((step + 1)%snap_idx == 0)
      {
        #pragma omp master
        {
          MPI_Barrier(MPI_COMM_WORLD); 
          if(rank == 0)
            save_snapshot(original_image, xwidth, ywidth, maxval, "snapshot", n_threads, step);
        }
      }




    }// End of evolution


  }
  // End of OpenMP parallel region

  if(image != NULL){
    free(image);
    image = NULL;
  }

  if(original_image != NULL){
    free(original_image);
    original_image = NULL;
  }

  MPI_Finalize();
}