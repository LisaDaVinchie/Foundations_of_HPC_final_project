#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <getopt.h>

#include <time.h>
#include <omp.h>
#include <mpi.h>

void write_pgm_image(char *image, int maxval, int xsize, int ysize, const char *image_name)
{
  FILE* image_file; 
  image_file = fopen(image_name, "wb"); 

  fprintf(image_file, "P4\n# generated by\n# put here your name\n%d %d\n%d\n", xsize, ysize, maxval);
  
  
  for (int i=0; i<xsize*ysize; i++)
            fprintf(image_file, "%c", image[i]);

  fclose(image_file); 
  return ;
}

void read_pgm_image( char **image, int *maxval, int *xsize, int *ysize, const char *image_name)

{
  FILE* image_file; 
  image_file = fopen(image_name, "r"); 

  *xsize = *ysize = *maxval = 0;
  
  char    MagicN[3];
  char   *line = NULL;
  size_t  k, n = 0;


  
  // get the Magic Number
  k = fscanf(image_file, "%2s%*c", MagicN);

  printf("Magic number read\n");
  // skip all the comments
  k = getline( &line, &n, image_file);
  printf("Comments skipped\n");
  while ( (k > 0) && (line[0]=='#') )
    k = getline( &line, &n, image_file);

  if (k > 0)
    {
      k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
      if ( k < 3 )
	fscanf(image_file, "%d%*c", maxval);
    }
  else
    {
      *maxval = -1;         // this is the signal that there was an I/O error
			    // while reading the image header
      free( line );
      return;
    }
  free( line );
  
  int color_depth = 1 + ( *maxval > 255 );
  unsigned int size = *xsize * *ysize * color_depth;
  
  if ( (*image = (char*)malloc( size )) == NULL )
    {
      fclose(image_file);
      *maxval = -2;         // this is the signal that memory was insufficient
      *xsize  = 0;
      *ysize  = 0;
      return;
    }
  
  if ( fread( *image, 1, size, image_file) != size )
    {
      free( image );
      image   = NULL;
      *maxval = -3;         // this is the signal that there was an i/o error
      *xsize  = 0;
      *ysize  = 0;
    }
    
    fclose(image_file);
  return;
}

void random_playground(char* image, int xsize, int ysize)
{
    int idx = 0;
    srand(time(NULL));
    for (int y = 0; y < ysize; y++){
        for (int x = 0; x < xsize; x++){
            image[idx] = (char)((int)rand()%2);
            idx++;
        }
    printf("\n");
    }
}


int count_live_neighbors(char* image, int row, int col, int xsize, int ysize){

  // Periodic boundary

  int xvalues[3];
  int yvalues[3];

  xvalues[1] = col;
  yvalues[1] = row;

  if(row == 0){
    yvalues[0] = ysize - 1;
    yvalues[2] = row + 1;
  }
  else if(row == ysize - 1){
    yvalues[0] = row - 1;
    yvalues[2] = 0;
  }
  else{
   yvalues[0] = row - 1;
   yvalues[2] = row + 1; 
  }

  if(col == 0){
    xvalues[0] = xsize - 1;
    xvalues[2] = col + 1;
  }
  else if(col == xsize - 1){
    xvalues[0] = col - 1;
    xvalues[2] = 0;
  }
  else{
   xvalues[0] = col - 1;
   xvalues[2] = col + 1; 
  }

  int sum = 0;
  for(int j = 0; j < 3; j++){
    for(int i = 0; i < 3; i++){
      if (i==1 && j==1){
        continue;
      }
      else{
        sum = sum + (int)(image[xvalues[i] + yvalues[j] * xsize]);
      }
    }
  }

return sum;
}


void ordered_evolution(char* image, int xsize, int ysize, int n, int s, char *destination_folder){

  int snap_idx = -1;
  if(s == 0){
    snap_idx = n;
  }
  else if(s > 0 && s < n){
    snap_idx = s;
  }
  else{
    printf("Wrong value for \"s\"\n");
  }
  
  for(int step = 0; step < n; step++){
    //ordered evolution
    for(int y = 0; y < ysize; y++){
      for (int x = 0; x < xsize; x++){
        //calculate status of cell in [x][y]
        int live_neighbors = -1;
        live_neighbors = count_live_neighbors(image, x, y, xsize, ysize);
        if (live_neighbors == 2 || live_neighbors == 3){
          image[x + y * xsize] = 1;
        }
        else if(live_neighbors < 0 || live_neighbors > 8){
          printf("There is an issue with the count of the neighbors that are alive, they cannot be %d\n", live_neighbors);
        }
        else{
          image[x + y * xsize] = 0;
        }
      }
    }

    if((step + 1)%snap_idx == 0){
      printf("\n");
      int idx = 0;
        for (int y = 0; y < ysize; y++){
            for (int x = 0; x < xsize; x++){
                idx++;
            }
      }
      char title[50];
      snprintf(title, 50, "%s_%d.pbm", destination_folder, step);
      write_pgm_image(image, 1, xsize, ysize, title);
    }
  }
}

void static_evolution(char* image, int xsize, int ysize, int n, int s, char *destination_folder){
  int snap_idx = -1;
  if(s == 0){
    snap_idx = n;
  }
  else if(s > 0 && s < n){
    snap_idx = s;
  }
  else{
    printf("Wrong value for \"s\"\n");
  }
  int temp_mat[xsize][ysize];
  for(int step = 0; step < n; step++){
      for(int y = 0; y < ysize; y++){
        for (int x = 0; x < xsize; x++){
          temp_mat[x][y] = -1;
          //calculate status of cell in [x][y]
          int live_neighbors = -1;
          live_neighbors = count_live_neighbors(image, x, y, xsize, ysize);
          if (live_neighbors == 2 || live_neighbors == 3){
            temp_mat[x][y] = 1;
          }
          else if(live_neighbors < 0 || live_neighbors > 8){
            printf("There is an issue with the count of the neighbors that are alive, they cannot be %d\n", live_neighbors);
          }
          else{
            temp_mat[x][y] = 0;
          }
        }
      }

    if((step + 1)%snap_idx == 0){
      int idx = 0;
      for(int y = 0; y < ysize; y++){
        for (int x = 0; x < xsize; x++){
          image[idx] = (char)temp_mat[x][y];
          idx++;
        }
      }
      char title[50];
      snprintf(title, 50, "%s_%d.pbm", destination_folder, step);
      write_pgm_image(image, 1, xsize, ysize, title);
    }
  }
}