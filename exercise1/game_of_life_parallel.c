#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <getopt.h>

#include <time.h>
#include <omp.h>
#include <mpi.h>


// Definitions for the argument getting part
#define INIT 1
#define RUN  2

#define K_DFLT 100

#define ORDERED 0
#define STATIC  1


// char fname_deflt[] = "game_of_life.pgm";

int   action = 0;
int   k      = K_DFLT;
int   e      = ORDERED;
int   n      = 10000;
int   s      = 1;
char *fname  = NULL;


//Definitions for the read and write pgm file
// #ifndef 
// #include <stdlib.h>
// #include <stdio.h> 
// #endif

// #define MAXVAL 255


// #if ((0x100 & 0xf) == 0x0)
// #define I_M_LITTLE_ENDIAN 1
// #define swap(mem) (( (mem) & (short int)0xff00) >> 8) +	\
//   ( ((mem) & (short int)0x00ff) << 8)
// #else
// #define I_M_LITTLE_ENDIAN 0
// #define swap(mem) (mem)
// #endif


void write_pgm_image(char *image, int maxval, int xsize, int ysize, const char *image_name)
/*
 * image        : a pointer to the memory region that contains the image
 * maxval       : either 255 or 65536
 * xsize, ysize : x and y dimensions of the image
 * image_name   : the name of the file to be written
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "wb"); 
  
  // Writing header
  // The header's format is as follows, all in ASCII.
  // "whitespace" is either a blank or a TAB or a CF or a LF
  // - The Magic Number (see below the magic numbers)
  // - the image's width
  // - the height
  // - a white space
  // - the image's height
  // - a whitespace
  // - the maximum color value, which must be between 0 and 65535
  //
  // if he maximum color value is in the range [0-255], then
  // a pixel will be expressed by a single byte; if the maximum is
  // larger than 255, then 2 bytes will be needed for each pixel
  //

//   int color_depth = 1 + ( maxval > 255 );

  fprintf(image_file, "P4\n# generated by\n# put here your name\n%d %d\n%d\n", xsize, ysize, maxval);
  
  
  for (int i=0; i<xsize*ysize; i++)
            fprintf(image_file, "%c", image[i]);

    // fwrite( image, sizeof(bool), xsize*ysize, image_file);

  fclose(image_file); 
  return ;

  /* ---------------------------------------------------------------

     TYPE    MAGIC NUM     EXTENSION   COLOR RANGE
           ASCII  BINARY

     PBM   P1     P4       .pbm        [0-1]
     PGM   P2     P5       .pgm        [0-255]
     PPM   P3     P6       .ppm        [0-2^16[
  
  ------------------------------------------------------------------ */
}

void read_pgm_image( char **image, int *maxval, int *xsize, int *ysize, const char *image_name)
/*
 * image        : a pointer to the pointer that will contain the image
 * maxval       : a pointer to the int that will store the maximum intensity in the image
 * xsize, ysize : pointers to the x and y sizes
 * image_name   : the name of the file to be read
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "r"); 

  // *image = NULL;
  *xsize = *ysize = *maxval = 0;
  
  char    MagicN[3];
  char   *line = NULL;
  size_t  k, n = 0;


  
  // get the Magic Number
  k = fscanf(image_file, "%2s%*c", MagicN);

  printf("Magic number read\n");
  // skip all the comments
  k = getline( &line, &n, image_file);
  printf("Comments skipped\n");
  while ( (k > 0) && (line[0]=='#') )
    k = getline( &line, &n, image_file);

  if (k > 0)
    {
      k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
      if ( k < 3 )
	fscanf(image_file, "%d%*c", maxval);
    }
  else
    {
      *maxval = -1;         // this is the signal that there was an I/O error
			    // while reading the image header
      free( line );
      return;
    }
  free( line );
  
  int color_depth = 1 + ( *maxval > 255 );
  unsigned int size = *xsize * *ysize * color_depth;
  
  if ( (*image = (char*)malloc( size )) == NULL )
    {
      fclose(image_file);
      *maxval = -2;         // this is the signal that memory was insufficient
      *xsize  = 0;
      *ysize  = 0;
      return;
    }
  
  if ( fread( *image, 1, size, image_file) != size )
    {
      free( image );
      image   = NULL;
      *maxval = -3;         // this is the signal that there was an i/o error
      *xsize  = 0;
      *ysize  = 0;
    }
    
    fclose(image_file);
  return;
}

void random_playground(char* image, int xsize, int ysize)
{
    int idx = 0;
    srand(time(NULL));
    for (int y = 0; y < ysize; y++){
        for (int x = 0; x < xsize; x++){
            // image[idx] = (char)((double)rand()/(double)RAND_MAX+0.5);
            image[idx] = (char)((int)rand()%2);
            // printf("%d ", (int)image[idx]);
            printf("%c ", image[idx] + 48);
            idx++;
        }
    printf("\n");
    }
}


int count_live_neighbors(char* image, int row, int col, int xsize, int ysize){

  // Periodic boundary

  int xvalues[3];
  int yvalues[3];

  xvalues[1] = col;
  yvalues[1] = row;

  if(row == 0){
    yvalues[0] = ysize - 1;
    yvalues[2] = row + 1;
  }
  else if(row == ysize - 1){
    yvalues[0] = row - 1;
    yvalues[2] = 0;
  }
  else{
   yvalues[0] = row - 1;
   yvalues[2] = row + 1; 
  }

  if(col == 0){
    xvalues[0] = xsize - 1;
    xvalues[2] = col + 1;
  }
  else if(col == xsize - 1){
    xvalues[0] = col - 1;
    xvalues[2] = 0;
  }
  else{
   xvalues[0] = col - 1;
   xvalues[2] = col + 1; 
  }

  int sum = 0;
  // char sum = 0;
  for(int j = 0; j < 3; j++){
    for(int i = 0; i < 3; i++){
      if (i==1 && j==1){
        continue;
      }
      else{
        // printf("x = %d, y = %d, cell = %c, int value = %d\n", xvalues[i], yvalues[j], image[xvalues[i] + yvalues[j] * xsize] + 48, (int)image[xvalues[i] + yvalues[j] * xsize]);
        sum = sum + (int)(image[xvalues[i] + yvalues[j] * xsize]);
      }
    }
  }

return sum;
}


void ordered_evolution(char* image, int xsize, int ysize, int n, int s, char *destination_folder){
  // int dump_idx = 0;

  int snap_idx = -1;
  if(s == 0){
    snap_idx = n;
  }
  else if(s > 0 && s < n){
    snap_idx = s;
  }
  else{
    printf("Wrong value for \"s\"\n");
  }
  
  for(int step = 0; step < n; step++){
    //ordered evolution
    for(int y = 0; y < ysize; y++){
      for (int x = 0; x < xsize; x++){
        //calculate status of cell in [x][y]
        int live_neighbors = -1;
        live_neighbors = count_live_neighbors(image, x, y, xsize, ysize);
        if (live_neighbors == 2 || live_neighbors == 3){
          image[x + y * xsize] = 1;
        }
        else if(live_neighbors < 0 || live_neighbors > 8){
          printf("There is an issue with the count of the neighbors that are alive, they cannot be %d\n", live_neighbors);
        }
        else{
          image[x + y * xsize] = 0;
        }
      }
    }

    if((step + 1)%snap_idx == 0){
      printf("\n");
      int idx = 0;
        for (int y = 0; y < ysize; y++){
            for (int x = 0; x < xsize; x++){
                printf("%c ", image[idx] + 48);
                idx++;
            }
        printf("\n");
      }
      char title[50];
      snprintf(title, 50, "%s_%d.pbm", destination_folder, step);
      // printf("%s\n",title);
      // dump_idx++;
      write_pgm_image(image, 1, xsize, ysize, title);
    }
  }
}

void static_evolution(char* image, int xsize, int ysize, int n, int s, char *destination_folder){
  int snap_idx = -1;
  if(s == 0){
    snap_idx = n;
  }
  else if(s > 0 && s < n){
    snap_idx = s;
  }
  else{
    printf("Wrong value for \"s\"\n");
  }
  int temp_mat[xsize][ysize];
  for(int step = 0; step < n; step++){
      for(int y = 0; y < ysize; y++){
        for (int x = 0; x < xsize; x++){
          temp_mat[x][y] = -1;
          //calculate status of cell in [x][y]
          int live_neighbors = -1;
          live_neighbors = count_live_neighbors(image, x, y, xsize, ysize);
          if (live_neighbors == 2 || live_neighbors == 3){
            temp_mat[x][y] = 1;
          }
          else if(live_neighbors < 0 || live_neighbors > 8){
            printf("There is an issue with the count of the neighbors that are alive, they cannot be %d\n", live_neighbors);
          }
          else{
            temp_mat[x][y] = 0;
          }
          // printf("%d", temp_mat[x][y]);
        }
        // printf("\n");
      }

    if((step + 1)%snap_idx == 0){
      int idx = 0;
      for(int y = 0; y < ysize; y++){
        for (int x = 0; x < xsize; x++){
          image[idx] = (char)temp_mat[x][y];
          printf("%c ", image[idx] + 48);
          idx++;
        }
        printf("\n");
      }
      printf("\n");
      char title[50];
      snprintf(title, 50, "%s_%d.pbm", destination_folder, step);
      write_pgm_image(image, 1, xsize, ysize, title);
    }
  }
}

// void read_image(){

// }
int main ( int argc, char **argv )
{

//Get the arguments, copy of Tornatore's "get_args.c" program
  int action = 0;
  char *optstring = "irk:e:f:n:s:";

  int c;
  while ((c = getopt(argc, argv, optstring)) != -1) {
    switch(c) {
      
    case 'i':
      action = INIT; break;
      
    case 'r':
      action = RUN; break;
      
    case 'k':
      k = atoi(optarg); break;

    case 'e':
      e = atoi(optarg); break;

    case 'f':
      fname = (char*)malloc(sizeof(optarg)+1 );
      sprintf(fname, "%s", optarg );
      break;

    case 'n': //number of steps to be calculated
      n = atoi(optarg); break;

    case 's': //every how many steps a dump is saved
      s = atoi(optarg);break;

    default :
      printf("argument -%c not known\n", c ); break;
    }
  }
  printf("action = %d\nk = %d\ne = %d\nf = %s\nn_steps = %d\nn_dump = %d\n", action, k, e, fname, n, s);

  int xwidth = k;
  int ywidth = k;
  int maxval = 1;

  int rank, n_procs;
  int mpi_provided_thread_level;

  MPI_Init_thread( &argc, &argv, MPI_THREAD_FUNNELED, &mpi_provided_thread_level);
  // MPI_THREAD_FUNNELED: The process may be multi-threaded, but only the main
  // thread will make MPI calls (funneled through the main thread).

  // &mpi_provided_thread_level: This is an output parameter.
  // After calling MPI_Init_thread, this variable will hold the actual level
  // of thread support provided by the MPI library.


  printf("Provided Thread level: %d\n", mpi_provided_thread_level);

  if ( mpi_provided_thread_level < MPI_THREAD_FUNNELED ){
    printf("a problem arise when asking for MPI_THREAD_FUNNELED level\n");
    MPI_Finalize();
    exit( 1 );
  } 

  MPI_Status status;
  // Declare variable "status" of type "MPI_Status" to hold info about
  // the outcome of a communication


  // Get the rank of the process and the total number of processes 
  MPI_Comm_size(MPI_COMM_WORLD, &n_procs);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);

  printf("Rank = %d, size = %d\n", rank, n_procs);


  // Get the number of OpenMP threads
  int n_threads = 0;

  #pragma omp parallel
  {
    #pragma omp master
    {
      n_threads = omp_get_num_threads();
      printf("OpenMP threads: %d\n", n_threads);
    }
  }

  // Get the number of threads per process
  // int threads_per_procs = 0;
  #pragma omp parallel
  {
    int threads_per_procs = omp_get_num_threads();
    printf("Threads per process: %d\n", threads_per_procs); 
  }

  

  // char* image = NULL;

  // initialise playground
  if(action == INIT){

    // distribute rows between MPI processes

    int row_per_proc = xwidth / n_procs; // rows for each process
    int remaining_rows = xwidth % nprocs; // remaining rows

    if (rank < remaining_rows){
      row_per_proc++;
    }

    unsigned int n_cells = row_per_proc * ywidth;


    char* image = (char*)malloc(n_cells * sizeof(char));

    #pragma omp parallel
    {
      int thread_id = omp_get_num_thread();
      
      int idx = 0;
      srand(time(NULL));

      #pragma omp for scedule(static, row_per_proc)
      for (int y = 0; y < ysize; y++){
          for (int x = 0; x < row_per_proc; x++){
              // image[idx] = (char)((double)rand()/(double)RAND_MAX+0.5);
              image[idx] = (char)((int)rand()%2);
              // printf("%d ", (int)image[idx]);
              printf("%c ", image[idx] + 48);
              idx++;
          }
      printf("\n");
    }
    }

    // random_playground(image, xwidth, ywidth);
    //write_pgm_image(image, maxval, xwidth, ywidth, fname);

    printf("\nInitial playground\n");
    int idx = 0;
      for (int y = 0; y < ywidth; y++){
          for (int x = 0; x < xwidth; x++){
              printf("%c ", image[idx] + 48);
              idx++;
          }
      printf("\n");
    }
  }

  else if(action == RUN){
    // char* image = NULL;
    // int maxval, xsize, ysize;
    // image = (char*)malloc(xwidth * ywidth * sizeof(char));
    printf("About to read playground\n");
    // char *source_image = "snapshots_static/initial_conditions.pgm";
    read_pgm_image(&image, &maxval, &xwidth, &ywidth, fname);
    printf("Playground read\n");

    int idx = 0;
    for (int y = 0; y < ywidth; y++){
      for (int x = 0; x < xwidth; x++){
          printf("%c ", image[idx] + 48);
          idx++;
      }
      printf("\n");
    }
    printf("\n"); 
    if(e == ORDERED){
      ordered_evolution(image, xwidth, ywidth, n, s, "snapshots_ordered/snap");
    }
    else if(e == STATIC){
      static_evolution(image, xwidth, ywidth, n, s, "snapshots_static/snap");
    }
    else{
      printf("Invalid value for flag \"-e\"\n");
      return 1;
    }
  
  }

  else{
    printf("Invalid value for variable \"action\"\n");
    return 1;
  }

  free(image);
  MPI_Finalize();
  return 0;
}